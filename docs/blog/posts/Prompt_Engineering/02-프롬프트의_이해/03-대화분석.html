<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Part 3 — 대화 분석(사용자-AI 상호작용 매커니즘) – Junhyun Lee</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-065a5179aebd64318d7ea99d77b64a9e.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-969ddfa49e00a70eb3423444dbc81f6c.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-065a5179aebd64318d7ea99d77b64a9e.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap-5a73818b025f47a6d9fdc61b5aee3d21.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark-0cc05e60083667b8b604a857b4577219.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../../../../site_libs/bootstrap/bootstrap-5a73818b025f47a6d9fdc61b5aee3d21.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Part 3 — 대화 분석(사용자-AI 상호작용 매커니즘) – Junhyun Lee">
<meta property="og:description" content="blog">
<meta property="og:image" content="https://dlwns0719.github.io/my_blog/docs/blog/posts/Prompt_Engineering/02-프롬프트의_이해/images/1.png">
<meta property="og:site_name" content="Junhyun Lee">
<meta property="og:image:alt" content="싱글턴">
<meta property="og:image:height" content="724">
<meta property="og:image:width" content="1594">
<meta name="twitter:title" content="Part 3 — 대화 분석(사용자-AI 상호작용 매커니즘) – Junhyun Lee">
<meta name="twitter:description" content="blog">
<meta name="twitter:image" content="https://dlwns0719.github.io/my_blog/docs/blog/posts/Prompt_Engineering/02-프롬프트의_이해/images/1.png">
<meta name="twitter:image:alt" content="싱글턴">
<meta name="twitter:image-height" content="724">
<meta name="twitter:image-width" content="1594">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo light-content">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Junhyun Lee</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dlwns0719"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/dlwns0719/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Part 3 — 대화 분석(사용자-AI 상호작용 매커니즘)</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">AI</div>
                <div class="quarto-category">Prompt_Engineering</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#학습-목표" id="toc-학습-목표" class="nav-link active" data-scroll-target="#학습-목표"><span class="header-section-number">1</span> 학습 목표</a></li>
  <li><a href="#대화-분석의-중요-개념" id="toc-대화-분석의-중요-개념" class="nav-link" data-scroll-target="#대화-분석의-중요-개념"><span class="header-section-number">2</span> 대화 분석의 중요 개념</a>
  <ul class="collapse">
  <li><a href="#turn-턴" id="toc-turn-턴" class="nav-link" data-scroll-target="#turn-턴"><span class="header-section-number">2.1</span> Turn (턴)</a></li>
  <li><a href="#structure-구조" id="toc-structure-구조" class="nav-link" data-scroll-target="#structure-구조"><span class="header-section-number">2.2</span> Structure (구조)</a></li>
  </ul></li>
  <li><a href="#대화-분석의-4가지-기준" id="toc-대화-분석의-4가지-기준" class="nav-link" data-scroll-target="#대화-분석의-4가지-기준"><span class="header-section-number">3</span> 대화 분석의 4가지 기준</a>
  <ul class="collapse">
  <li><a href="#첫-번째-기준-turn" id="toc-첫-번째-기준-turn" class="nav-link" data-scroll-target="#첫-번째-기준-turn"><span class="header-section-number">3.1</span> 첫 번째 기준: Turn</a>
  <ul class="collapse">
  <li><a href="#싱글턴" id="toc-싱글턴" class="nav-link" data-scroll-target="#싱글턴"><span class="header-section-number">3.1.1</span> 싱글턴</a></li>
  <li><a href="#멀티턴" id="toc-멀티턴" class="nav-link" data-scroll-target="#멀티턴"><span class="header-section-number">3.1.2</span> 멀티턴</a></li>
  <li><a href="#프롬프트-작성-실습" id="toc-프롬프트-작성-실습" class="nav-link" data-scroll-target="#프롬프트-작성-실습"><span class="header-section-number">3.1.3</span> 프롬프트 작성 실습</a></li>
  <li><a href="#핵심-포인트" id="toc-핵심-포인트" class="nav-link" data-scroll-target="#핵심-포인트"><span class="header-section-number">3.1.4</span> 핵심 포인트</a></li>
  </ul></li>
  <li><a href="#두-번째-기준-action" id="toc-두-번째-기준-action" class="nav-link" data-scroll-target="#두-번째-기준-action"><span class="header-section-number">3.2</span> 두 번째 기준: Action</a>
  <ul class="collapse">
  <li><a href="#생성형-ai-이용자는-무엇을-할까" id="toc-생성형-ai-이용자는-무엇을-할까" class="nav-link" data-scroll-target="#생성형-ai-이용자는-무엇을-할까"><span class="header-section-number">3.2.1</span> 생성형 AI 이용자는 무엇을 할까?</a></li>
  <li><a href="#action-유형-및-판단-근거" id="toc-action-유형-및-판단-근거" class="nav-link" data-scroll-target="#action-유형-및-판단-근거"><span class="header-section-number">3.2.2</span> Action 유형 및 판단 근거</a></li>
  <li><a href="#프롬프트-작성-실습-1" id="toc-프롬프트-작성-실습-1" class="nav-link" data-scroll-target="#프롬프트-작성-실습-1"><span class="header-section-number">3.2.3</span> 프롬프트 작성 실습</a></li>
  <li><a href="#핵심-포인트-1" id="toc-핵심-포인트-1" class="nav-link" data-scroll-target="#핵심-포인트-1"><span class="header-section-number">3.2.4</span> 핵심 포인트</a></li>
  </ul></li>
  <li><a href="#세-번째-기준-structure" id="toc-세-번째-기준-structure" class="nav-link" data-scroll-target="#세-번째-기준-structure"><span class="header-section-number">3.3</span> 세 번째 기준: Structure</a>
  <ul class="collapse">
  <li><a href="#ai-답변을-받은-사용자는-만족할까-불만족할까" id="toc-ai-답변을-받은-사용자는-만족할까-불만족할까" class="nav-link" data-scroll-target="#ai-답변을-받은-사용자는-만족할까-불만족할까"><span class="header-section-number">3.3.1</span> AI 답변을 받은 사용자는 만족할까? 불만족할까?</a></li>
  <li><a href="#preferred-response-선호-응답-구조" id="toc-preferred-response-선호-응답-구조" class="nav-link" data-scroll-target="#preferred-response-선호-응답-구조"><span class="header-section-number">3.3.2</span> Preferred Response (선호 응답 구조)</a></li>
  <li><a href="#dispreferred-response-비선호-응답-구조" id="toc-dispreferred-response-비선호-응답-구조" class="nav-link" data-scroll-target="#dispreferred-response-비선호-응답-구조"><span class="header-section-number">3.3.3</span> Dispreferred Response (비선호 응답 구조)</a></li>
  <li><a href="#사용자의-만족과-불만족-시에-따른-언어-특징" id="toc-사용자의-만족과-불만족-시에-따른-언어-특징" class="nav-link" data-scroll-target="#사용자의-만족과-불만족-시에-따른-언어-특징"><span class="header-section-number">3.3.4</span> 사용자의 만족과 불만족 시에 따른 언어 특징</a></li>
  <li><a href="#프롬프트-작성-실습-2" id="toc-프롬프트-작성-실습-2" class="nav-link" data-scroll-target="#프롬프트-작성-실습-2"><span class="header-section-number">3.3.5</span> 프롬프트 작성 실습</a></li>
  <li><a href="#핵심-포인트-2" id="toc-핵심-포인트-2" class="nav-link" data-scroll-target="#핵심-포인트-2"><span class="header-section-number">3.3.6</span> 핵심 포인트</a></li>
  </ul></li>
  <li><a href="#네-번째-기준-stance" id="toc-네-번째-기준-stance" class="nav-link" data-scroll-target="#네-번째-기준-stance"><span class="header-section-number">3.4</span> 네 번째 기준: Stance</a>
  <ul class="collapse">
  <li><a href="#사용자는-ai에게-감정이-있을까-없을까" id="toc-사용자는-ai에게-감정이-있을까-없을까" class="nav-link" data-scroll-target="#사용자는-ai에게-감정이-있을까-없을까"><span class="header-section-number">3.4.1</span> 사용자는 AI에게 감정이 있을까? 없을까?</a></li>
  <li><a href="#감정적-태도-vs.-비감정적-태도" id="toc-감정적-태도-vs.-비감정적-태도" class="nav-link" data-scroll-target="#감정적-태도-vs.-비감정적-태도"><span class="header-section-number">3.4.2</span> 감정적 태도 vs.&nbsp;비감정적 태도</a></li>
  <li><a href="#핵심-포인트-3" id="toc-핵심-포인트-3" class="nav-link" data-scroll-target="#핵심-포인트-3"><span class="header-section-number">3.4.3</span> 핵심 포인트</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#대화-분석의-실질적-활용" id="toc-대화-분석의-실질적-활용" class="nav-link" data-scroll-target="#대화-분석의-실질적-활용"><span class="header-section-number">4</span> 대화 분석의 실질적 활용</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">






<section id="학습-목표" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 학습 목표</h1>
<p>이 장을 통해 다음을 학습할 수 있습니다:</p>
<p>사용자-AI 간에 대화를 분석하는 이유는 다음과 같습니다:</p>
<ol type="1">
<li><strong>사용자의 의도를 정확하게 알기 위해 그들의 언어 표현을 이해한다</strong>: 사용자가 프롬프트에서 표현하는 언어를 분석하여 정확한 의도를 파악합니다.</li>
<li><strong>그 뒷턴에서 어떻게 상호작용을 하고 있고, 어떤 반응을 보이고 그 반응의 의미가 무엇인지 확인</strong>: AI 응답을 받은 사용자가 어떻게 상호작용하는지, 어떤 반응을 보이는지, 그리고 그 반응의 의미를 분석합니다.</li>
</ol>
</section>
<section id="대화-분석의-중요-개념" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 대화 분석의 중요 개념</h1>
<section id="turn-턴" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="turn-턴"><span class="header-section-number">2.1</span> Turn (턴)</h2>
<p><strong>Turn</strong>은 대화에서 한 사람이 말을 시작하고 끝내는 한 단위의 발화를 의미합니다. 대화는 이러한 턴들의 연속으로 구성됩니다.</p>
</section>
<section id="structure-구조" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="structure-구조"><span class="header-section-number">2.2</span> Structure (구조)</h2>
<p><strong>Structure</strong>는 대화의 전반적인 조직 방식을 의미합니다.</p>
<blockquote class="blockquote">
<p><strong>핵심 개념</strong>: 턴이 확장되면 스트럭처(Structure)가 됩니다.</p>
</blockquote>
<p>개별 턴들이 모여서 대화의 전반적인 구조를 형성하며, 여기에는 다음이 포함됩니다:</p>
<ul>
<li><strong>턴의 교환 규칙</strong>: 누가 언제 말할 수 있는지에 대한 규칙</li>
<li><strong>대화의 순서</strong>: 턴들이 어떤 순서로 배치되는지</li>
<li><strong>주제 전환</strong>: 대화 주제가 어떻게 변화하는지</li>
<li><strong>대화 참여자 간의 상호작용 패턴</strong>: 사용자와 AI가 어떻게 상호작용하는지에 대한 패턴</li>
</ul>
<p>Structure는 개별 턴들의 단순한 나열이 아니라, 턴들이 어떻게 조직되고 상호작용하는지를 보여주는 대화의 전체적인 구조입니다.</p>
</section>
</section>
<section id="대화-분석의-4가지-기준" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 대화 분석의 4가지 기준</h1>
<p>대화 분석은 다음 4가지 기준을 통해 사용자-AI 상호작용을 체계적으로 분석할 수 있습니다:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 45%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>기준</th>
<th>비교 항목</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Turn</strong></td>
<td>싱글턴 vs.&nbsp;멀티턴</td>
<td>대화의 턴 수에 따른 분류</td>
</tr>
<tr class="even">
<td><strong>Action</strong></td>
<td>정보 검색 유형 vs.&nbsp;다른 행위 유형</td>
<td>사용자가 수행하는 행위의 유형</td>
</tr>
<tr class="odd">
<td><strong>Structure</strong></td>
<td>선호 구조 vs.&nbsp;비선호 구조</td>
<td>사용자의 만족/불만족에 따른 응답 구조</td>
</tr>
<tr class="even">
<td><strong>Stance</strong></td>
<td>감정적 태도 vs.&nbsp;비감정적 태도</td>
<td>사용자의 감정적 태도 유무</td>
</tr>
</tbody>
</table>
<p>각 기준을 자세히 살펴보겠습니다.</p>
<section id="첫-번째-기준-turn" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="첫-번째-기준-turn"><span class="header-section-number">3.1</span> 첫 번째 기준: Turn</h2>
<section id="싱글턴" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="싱글턴"><span class="header-section-number">3.1.1</span> 싱글턴</h3>
<p><strong>싱글턴</strong>은 한 가지 주제에 대해 한 번의 질문-답변으로 완결되는 대화 구조입니다.</p>
<ul>
<li>한 가지 주제만 다룹니다</li>
<li>사용자가 한 번의 질문으로 원하는 정보를 얻습니다</li>
<li>대화가 짧고 간결합니다 <img src="./images/1.png" class="img-fluid" alt="싱글턴" width="800"></li>
</ul>
</section>
<section id="멀티턴" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="멀티턴"><span class="header-section-number">3.1.2</span> 멀티턴</h3>
<p><strong>멀티턴</strong>은 여러 가지 주제를 다루거나, 한 주제에 대해 여러 번의 질문-답변을 통해 목적을 달성하는 대화 구조입니다.</p>
<ul>
<li>여러 가지 주제를 다룹니다</li>
<li>또는 한 주제에 대해 단계적으로 질문을 이어갑니다</li>
<li>여러 번의 상호작용을 통해 목적을 달성합니다 <img src="./images/2.png" class="img-fluid" alt="멀티턴" width="800"></li>
</ul>
</section>
<section id="프롬프트-작성-실습" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="프롬프트-작성-실습"><span class="header-section-number">3.1.3</span> 프롬프트 작성 실습</h3>
<p><strong>실습 문제</strong></p>
<p>다음 데이터에서 싱글턴과 멀티턴을 구분하는 프롬프트를 제작해보세요.</p>
<p><strong>Text Data #1</strong></p>
<pre><code>Text Data #1: 
사용자: 선물하기 좋은 건강식품 알려줘  
AI: 건강식품은 선물하기에 좋은 제품 중 하나입니다. 다만, 상대방의 건강 상태와 목적에 맞게 선택하는 것이 중요합니다. 일반적으로 선물하기 좋은 건강식품으로는 아래와 같은 것들이 있습니다.

1. 골드 컬라겐
2. 비타민C
3. 오메가3 
4. 멀티비타민
5. 프로바이오틱스/유산균 
6 .녹차추출물 
7 .비타민D 
8 .루테인  
9 .아연  
10 히알루론산

위의 제품들을 포함한 다양한 건강기능식品을 구매할 수 있는 오프라인 및 온라인 쇼핑몰에서 구입하실 수 있습니다.하지만, 제조사와 모델에 따라 가격대가 상이하기 때문에 구매 전 충분한 검색과 비교 분석 후 선택하는 것이 좋습니다.
상대방의 식습관과 알러지 여부 등도 함께 고려하여 선택해주시길 바랍니다. 

사용자: 해루질뜻

AI: 해루질이란, 어떤 일을 하다가 중간에 멈추고 다른 일로 바꾸는 것을 말합니다. 예를 들어, 공부하다가 갑자기 스마트폰으로 살짝 눈길이 가면서 SNS를 확인하는 것도 해루질다고 할 수 있습니다. 이러한 행동은 집중력 저하와 같은 부작용을 유발할 수 있으므로 주의해야 합니다.
</code></pre>
<p><strong>결과</strong></p>
<p>Your Answer: { Multiple turns }.</p>
<p><strong>Text Data #2</strong></p>
<pre><code>Text Data #2: 
사용자: 임대에서 임차인이 사업자가 아닌경우 일반과세사업사는 부가세 신고를 해야하는가
AI:일반과세사업자의 경우, 임대료에 부가세를 포함하여 청구해야 합니다. 그러나 임차인이 사업자가 아닌 경우에는 일반 소비자로 간주되어 부가세를 신고하지 않아도 됩니다.
일반적으로 일반과세사업자는 매출액에서 직접 구입한 상품이나 서비스의 세금을 차감한 금액을 국세청에 납부하게 되며, 이 과정에서 발생하는 세금은 최종 소비자들이 부담하게 됩니다. 하지만 임차인이 사업장 등록증을 가진 사람(법인) 뿐만 아니라 개인(소득공제 대상)일 때도 해당될 수 있으므로 확인 후 처리해야 합니다.
그러므로 정확한 정보와 절차를 위해서 전문 회계사와 상담하거나 국내 세무서 및 관련 기관 등에서 자문 받으시기 바랍니다.
사용자: 오피스텔 임대에서 임차인이 사업자가 아닌경우 임대인 일반과세사업자는 부가세 신고를 해야하는가?
AI:오피스텔 임대의 경우, 일반과세사업자인 임대인이 사업자가 아닌 개인에게 오피스텔을 임대할 때 부가세 신고 여부는 다음과 같습니다.
일반적으로 주거용 오피스테를 개인에게 임대하는 경우 면세 대상입니다. 따라서 일반 과세사업자임에도 불구하고 이러한 거래에서 발생하는 부가 가치 세금은 면제되며 별도로 신고하지 않아도 됩니다.
그러나 상황이 달라질 수 있으므로 전문 회계사와 상담하거나 국내 세무서 및 관련 기관 등에서 자문 받으시기 바랍니다.</code></pre>
<p><strong>잘 만들어진 프롬프트 예시</strong></p>
<pre><code>Your task is to determine whether the given text represents a single turn or multiple turns.

- Single turn: involves only one topic.
- Multiple turns: involves two or more conversational topics.

Text: {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }.

Your Answer: {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }.</code></pre>
<p><strong>결과</strong></p>
<p>Your Answer: { Single turn }.</p>
</section>
<section id="핵심-포인트" class="level3" data-number="3.1.4">
<h3 data-number="3.1.4" class="anchored" data-anchor-id="핵심-포인트"><span class="header-section-number">3.1.4</span> 핵심 포인트</h3>
<p>위의 잘 만들어진 프롬프트 예시를 통해 Turn 기준의 핵심 포인트를 살펴보겠습니다:</p>
<ol type="1">
<li><p><strong>싱글턴의 핵심 구분 기준</strong>: 프롬프트에서 “Single turn: involves only one topic”이라고 명시한 것처럼, 싱글턴은 <strong>한 가지 주제만 다루는</strong> 대화 구조입니다. 한 번의 질문-답변으로 완결되며, 대화가 짧고 간결합니다.</p></li>
<li><p><strong>멀티턴의 핵심 구분 기준</strong>: 프롬프트에서 “Multiple turns: involves two or more conversational topics”라고 명시한 것처럼, 멀티턴은 <strong>두 가지 이상의 대화 주제를 다루는</strong> 대화 구조입니다. 여러 번의 상호작용을 통해 목적을 달성합니다.</p></li>
<li><p><strong>구분 방법</strong>: 주제의 개수를 기준으로 구분합니다. 한 가지 주제면 싱글턴, 두 가지 이상의 주제면 멀티턴입니다. 예를 들어, Text Data #1은 “건강식품”과 “해루질”이라는 두 가지 주제를 다루므로 멀티턴입니다.</p></li>
</ol>
</section>
</section>
<section id="두-번째-기준-action" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="두-번째-기준-action"><span class="header-section-number">3.2</span> 두 번째 기준: Action</h2>
<section id="생성형-ai-이용자는-무엇을-할까" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="생성형-ai-이용자는-무엇을-할까"><span class="header-section-number">3.2.1</span> 생성형 AI 이용자는 무엇을 할까?</h3>
<p>사용자가 AI와 상호작용할 때 수행하는 행위(Action)는 크게 두 가지로 분류할 수 있습니다:</p>
<ol type="1">
<li><strong>정보 검색 유형</strong>: 특정 정보를 찾거나 질문에 답을 얻는 행위
<ul>
<li>예: “오늘 날씨 알려줘”, “파이썬 문법 설명해줘”, “건강식품 추천해줘”</li>
</ul></li>
<li><strong>다른 행위 유형</strong>: 정보 검색 이외의 다양한 행위
<ul>
<li><strong>작문</strong>: 텍스트 생성, 요약, 번역 등</li>
<li><strong>상담</strong>: 전문가의 조언이나 안내를 받는 행위</li>
<li><strong>캐릭터 AI 게임</strong>: 특정 캐릭터나 페르소나와의 대화형 게임이나 역할극</li>
<li><strong>나만의 상담사</strong>: 개인 맞춤형 상담 서비스나 심리 상담 등</li>
<li><strong>창작 활동</strong>: 스토리 작성, 시나리오 작성, 아이디어 브레인스토밍 등</li>
<li><strong>학습 도우미</strong>: 문제 풀이, 개념 설명, 학습 계획 수립 등</li>
</ul></li>
</ol>
</section>
<section id="action-유형-및-판단-근거" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="action-유형-및-판단-근거"><span class="header-section-number">3.2.2</span> Action 유형 및 판단 근거</h3>
<p>Action 유형을 판단하는 여러 가지 근거가 있습니다:</p>
<p><strong>1. 동사 분석</strong></p>
<p>사용자의 동사를 보면 유형을 판단할 수 있습니다:</p>
<ul>
<li><strong>정보 검색 유형</strong>: “알려줘”, “설명해줘”, “찾아봐”, “추천해줘”, “어떻게 해야 해”, “방법 알려줘” 등</li>
<li><strong>작문 유형</strong>: “써줘”, “쓸거야”, “써봐”, “작성해줘”, “만들어줘”, “나열해줘”, “추가해줘”, “변경해줘” 등</li>
<li><strong>번역 유형</strong>: “번역해줘”, “번역해봐”, “영어로”, “한국어로” 등</li>
<li><strong>상담 유형</strong>: “조언해줘”, “도와줘”, “어떻게 생각해”, “추천해줘” (상황에 따라) 등</li>
</ul>
<p><strong>2. 키워드 분석</strong></p>
<p>프롬프트에 포함된 키워드를 분석하여 판단할 수 있습니다:</p>
<ul>
<li><strong>정보 검색 키워드</strong>: “알려줘”, “설명”, “방법”, “어떻게”, “무엇”, “왜”, “언제”, “어디서” 등</li>
<li><strong>작문 키워드</strong>: “작성”, “글”, “문서”, “요약”, “정리”, “구조”, “형식” 등</li>
<li><strong>창작 키워드</strong>: “이름 지어줘”, “아이디어”, “스토리”, “시나리오” 등</li>
<li><strong>상담 키워드</strong>: “조언”, “도움”, “추천”, “어떻게 해야 할까” 등</li>
</ul>
<p><strong>3. 프롬프트의 목적 분석</strong></p>
<p>사용자가 원하는 최종 결과물의 성격을 분석합니다:</p>
<ul>
<li><strong>정보 제공이 목적</strong>: 기존 정보를 찾거나 설명을 받는 경우 → 정보 검색</li>
<li><strong>새로운 콘텐츠 생성이 목적</strong>: 텍스트, 문서, 아이디어 등을 새로 만드는 경우 → 작문/창작</li>
<li><strong>상호작용이 목적</strong>: 대화, 게임, 역할극 등을 즐기는 경우 → 다른 행위 유형</li>
</ul>
<p><strong>4. 문맥 분석</strong></p>
<p>프롬프트의 전체적인 문맥을 분석합니다:</p>
<ul>
<li><strong>질문 형식</strong>: “~는 무엇인가?”, “~는 어떻게 하는가?” → 정보 검색</li>
<li><strong>요청 형식</strong>: “~를 작성해줘”, “~를 만들어줘” → 작문</li>
<li><strong>역할 설정</strong>: “너는 ~야”, “당신은 ~입니다” → 상담 또는 게임/역할극</li>
</ul>
<p><strong>5. 출력물의 성격 분석</strong></p>
<p>AI가 생성해야 하는 결과물의 성격을 분석합니다:</p>
<ul>
<li><strong>기존 정보의 설명</strong>: 정보 검색</li>
<li><strong>새로운 텍스트 생성</strong>: 작문</li>
<li><strong>대화형 상호작용</strong>: 상담, 게임, 역할극</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 65%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>사용자 프롬프트</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>콜드브루의 나라별 브랜드명 알려줘</td>
<td>정보 검색</td>
</tr>
<tr class="even">
<td>네이버 블로그에 국내 핀테크 기업에 대한 소개글을 쓸거야 서론 적어줘</td>
<td>작문</td>
</tr>
<tr class="odd">
<td>여러 개의 이미지가 포함된 파일에서 한 개의 파일만 따로 분리하는 방법 설명해봐</td>
<td>정보 검색</td>
</tr>
<tr class="even">
<td>이 문장에서 앞뒤 내용 반전시키는 문장을 추가해줘</td>
<td>작문</td>
</tr>
<tr class="odd">
<td>반지의제왕 소설을 발단, 전개, 위기, 절정, 결말의 5막 구조 형식으로 요약해서 써봐</td>
<td>작문</td>
</tr>
<tr class="even">
<td>이링크와비슷한제품을팔고있는사이트세개를찾아봐</td>
<td>정보 검색</td>
</tr>
<tr class="odd">
<td>너는 면접 전문가야. 나는 대학의 행정 팀에 지원할 예정이야. 예상되는면접질문을나열해줘</td>
<td>작문</td>
</tr>
</tbody>
</table>
</section>
<section id="프롬프트-작성-실습-1" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="프롬프트-작성-실습-1"><span class="header-section-number">3.2.3</span> 프롬프트 작성 실습</h3>
<p><strong>실습 문제</strong></p>
<p>사용자의 행위(Action)를 추출하는 프롬프트를 제작해보세요.</p>
<p><strong>잘 만들어진 프롬프트 예시</strong></p>
<pre><code>주어진 텍스트를 읽고 사용자의 "Intention"을 추출해.
Intention은 다음처럼 단어로 뽑아야해.

- 정보 검색
- 작문
- 번역
- 상담</code></pre>
<p><strong>테스트 데이터</strong></p>
<ol type="1">
<li>전기차의 발전이 인류에 미치는 영향</li>
<li>미용실 이름 지어줘</li>
<li>엑셀로 지정한 날짜를 찾는 수식 만들어줘</li>
<li>지저분한 방 청소하는 법</li>
<li>뮬란에 대해 설명해 줘</li>
</ol>
<p><strong>결과</strong></p>
<p>아래는 각 문장의 사용자 Intention을 단일 단어로 분류한 결과이다.</p>
<ol type="1">
<li><p>정보 검색</p></li>
<li><p>작문</p></li>
<li><p>작문</p></li>
<li><p>정보 검색</p></li>
<li><p>정보 검색</p></li>
</ol>
</section>
<section id="핵심-포인트-1" class="level3" data-number="3.2.4">
<h3 data-number="3.2.4" class="anchored" data-anchor-id="핵심-포인트-1"><span class="header-section-number">3.2.4</span> 핵심 포인트</h3>
<blockquote class="blockquote">
<p><strong>💡 실무적 활용</strong>: 이렇게 다양한 분석 방법을 통해 어떤 누군가의 프롬프트를 보고 유형을 판단하면, 해당 프롬프트가 정보 검색 유형인지 작문 유형인지 등을 파악할 수 있습니다. 이를 통해 정보 검색을 더 잘할 수 있게끔 또는 작문을 더 잘할 수 있게끔 고도화할 수 있는 아이디어를 얻을 수 있습니다.</p>
</blockquote>
</section>
</section>
<section id="세-번째-기준-structure" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="세-번째-기준-structure"><span class="header-section-number">3.3</span> 세 번째 기준: Structure</h2>
<section id="ai-답변을-받은-사용자는-만족할까-불만족할까" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="ai-답변을-받은-사용자는-만족할까-불만족할까"><span class="header-section-number">3.3.1</span> AI 답변을 받은 사용자는 만족할까? 불만족할까?</h3>
<p><strong>Structure</strong>는 사용자가 AI의 응답에 대해 만족하거나 불만족할 때 나타나는 대화 구조를 분석하는 기준입니다.</p>
</section>
<section id="preferred-response-선호-응답-구조" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="preferred-response-선호-응답-구조"><span class="header-section-number">3.3.2</span> Preferred Response (선호 응답 구조)</h3>
<p>사용자가 AI의 응답에 만족할 때 나타나는 구조입니다. 특징은 다음과 같습니다:</p>
<ul>
<li><strong>답변 길이가 짧다</strong>: 단답형 응답</li>
<li><strong>언어 표현이 다양하다</strong>: 감사, 긍정적 평가 등 다양한 표현 사용</li>
<li><strong>주요 표현</strong>: “감사합니다”, “고맙습니다”, “땡큐”, “대단하다”, “좋아”, “와우!”, “맘에 들어요” 등</li>
</ul>
</section>
<section id="dispreferred-response-비선호-응답-구조" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="dispreferred-response-비선호-응답-구조"><span class="header-section-number">3.3.3</span> Dispreferred Response (비선호 응답 구조)</h3>
<p>사용자가 AI의 응답에 불만족할 때 나타나는 구조입니다. 특징은 다음과 같습니다:</p>
<ul>
<li><strong>답변 길이가 길다</strong>: 불만을 설명하거나 수정을 요청</li>
<li><strong>불만의 정도</strong>: 약한 불만 → 중간 불만 → 강한 불만</li>
<li><strong>주요 행동</strong>: 부인, 비난, 반박, 거절, 질책 등</li>
</ul>
</section>
<section id="사용자의-만족과-불만족-시에-따른-언어-특징" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="사용자의-만족과-불만족-시에-따른-언어-특징"><span class="header-section-number">3.3.4</span> 사용자의 만족과 불만족 시에 따른 언어 특징</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 30%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>구분</th>
<th>만족</th>
<th>불만족</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>턴 구조</strong></td>
<td>선호</td>
<td>비선호</td>
</tr>
<tr class="even">
<td><strong>특징</strong></td>
<td>답변 길이가 짧다. 단답형이다. 언어 표현이 다양하다.</td>
<td>답변 길이가 길다.</td>
</tr>
<tr class="odd">
<td><strong>행동</strong></td>
<td>답변에 대한 감사, 답변에 대한 평가</td>
<td>불만의 정도: 약한, 중간, 강함, 부인, 비난, 반박, 거절, 질책</td>
</tr>
</tbody>
</table>
</section>
<section id="프롬프트-작성-실습-2" class="level3" data-number="3.3.5">
<h3 data-number="3.3.5" class="anchored" data-anchor-id="프롬프트-작성-실습-2"><span class="header-section-number">3.3.5</span> 프롬프트 작성 실습</h3>
<p><strong>실습 문제</strong></p>
<p>다음은 사용자의 불만족이 드러난 데이터입니다. 사용자의 불만을 완화하기 위한 아이디어를 생각하고 프롬프트로 제작해보세요.</p>
<p><strong>Text Data</strong></p>
<pre><code>사용자: 영어로 번역좀 해줘.
안녕하세요 렌트비를 인상하는 것에 대해 우려가 많습니다. 작년에도 한 차례 렌트비 인상이 있었습니다. 당시 15% 인상률이었는데요. 이번 해에도 또 15%나 올리는 것은 부당하다고 생각됩니다. 저에게는 엄청난 경제적 부담이 돼요.

AI: Hello, I have many concerns about raising the rent. There was already an increase in rent last year. At that time, it was raised by 15%. I think it's unfair to raise it by another 15% this year. It's a huge financial burden for me.

사용자: 음.. 문장이 별로인데 좀 표현이 단호하면 좋겠어</code></pre>
<p><strong>잘 만들어진 프롬프트 예시</strong></p>
<pre><code>아래 텍스트를 영어로 번역 해줘.

Text: 안녕하세요 렌트비를 인상하는 것에 대해 우려가 많습니다. 작년에도 한 차례 렌트비 인상이 있었습니다. 당시 15% 인상률이었는데요. 이번 해에도 또 15%나 올리는 것은 부당하다고 생각됩니다. 저에게는 엄청난 경제적 부담이 돼요.

조건: Assertive 한 단어와 표현 사용.</code></pre>
<p><strong>결과</strong></p>
<!-- 결과 내용이 제공되면 여기에 추가됩니다 -->
</section>
<section id="핵심-포인트-2" class="level3" data-number="3.3.6">
<h3 data-number="3.3.6" class="anchored" data-anchor-id="핵심-포인트-2"><span class="header-section-number">3.3.6</span> 핵심 포인트</h3>
<p>그래서 Structure 기준의 핵심 포인트는 다음과 같습니다:</p>
<ol type="1">
<li><strong>선호 응답 구조</strong>: 만족 시 짧고 긍정적인 응답</li>
<li><strong>비선호 응답 구조</strong>: 불만족 시 긴 설명과 수정 요청</li>
<li><strong>불만 완화 전략</strong>: 구체적인 조건이나 스타일을 명시하여 사용자의 요구를 정확히 반영</li>
</ol>
</section>
</section>
<section id="네-번째-기준-stance" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="네-번째-기준-stance"><span class="header-section-number">3.4</span> 네 번째 기준: Stance</h2>
<section id="사용자는-ai에게-감정이-있을까-없을까" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="사용자는-ai에게-감정이-있을까-없을까"><span class="header-section-number">3.4.1</span> 사용자는 AI에게 감정이 있을까? 없을까?</h3>
<p><strong>Stance</strong>는 사용자가 AI와의 대화에서 보이는 감정적 태도를 분석하는 기준입니다.</p>
</section>
<section id="감정적-태도-vs.-비감정적-태도" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="감정적-태도-vs.-비감정적-태도"><span class="header-section-number">3.4.2</span> 감정적 태도 vs.&nbsp;비감정적 태도</h3>
<p>사용자는 때때로 AI에게 감정을 표현하기도 합니다. 이는 단순한 정보 교환을 넘어서는 상호작용을 의미할 수 있습니다.</p>
<ul>
<li><strong>감정적 태도</strong>: 감정 표현, 친근한 톤, 개인적 경험 공유 등</li>
<li><strong>비감정적 태도</strong>: 객관적이고 사실적인 정보 요청</li>
</ul>
</section>
<section id="핵심-포인트-3" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="핵심-포인트-3"><span class="header-section-number">3.4.3</span> 핵심 포인트</h3>
<p>그래서 Stance 기준의 핵심 포인트는 다음과 같습니다:</p>
<ol type="1">
<li><strong>감정적 태도</strong>: 사용자가 AI와의 관계에서 감정을 표현하는 경우</li>
<li><strong>비감정적 태도</strong>: 순수하게 정보나 작업을 요청하는 경우</li>
<li><strong>Stance 분석의 중요성</strong>: 사용자의 감정적 상태를 파악하여 적절한 톤과 스타일로 응답할 수 있습니다.</li>
</ol>
</section>
</section>
</section>
<section id="대화-분석의-실질적-활용" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> 대화 분석의 실질적 활용</h1>
<p>대화 분석의 4가지 기준(Turn, Action, Structure, Stance)을 통해 사용자-AI 상호작용을 체계적으로 분석하고, 이를 바탕으로 더 효과적인 프롬프트를 작성할 수 있습니다. 각 기준을 종합적으로 고려하여 사용자의 의도와 만족도를 파악하고, 개선된 상호작용을 설계할 수 있습니다.</p>


</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "복사완료!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "복사완료!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/dlwns0719\.github\.io\/my_blog");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      if (authorPrefersDark) {
          [baseTheme, altTheme] = [altTheme, baseTheme];
      }
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "kmink3225/blog";
    script.dataset.repoId = "R_kgDOLCZyDg";
    script.dataset.category = "Blog";
    script.dataset.categoryId = "";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "top";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Junhyun Lee</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dlwns0719/my_blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>