[
  {
    "objectID": "about.html#enthusiastic-data-scientist",
    "href": "about.html#enthusiastic-data-scientist",
    "title": "Kwangmin Kim",
    "section": "2 Enthusiastic Data Scientist",
    "text": "2 Enthusiastic Data Scientist\n\n2.1 Interests\nData Modeling, Statistics, Machine Learning, Deep Learning, Optimization"
  },
  {
    "objectID": "docs/blog/index.html",
    "href": "docs/blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nOpenAI 외 도구 호출 에이전트(Tool Calling Agent)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n도구 (Tools)\n\n\n\n\n\n\nAI\n\nLangChain\n\nPrompt_Engineering\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIteration 기능과 사람 개입(Human-in-the-loop)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLLM 에 도구 바인딩(Binding Tools)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n도구 호출 에이전트(Tool Calling Agent)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPart 1 — 프롬프트 구조와 기능 탐구\n\n\n\n\n\n\nAI\n\nLangChain\n\nPrompt_Engineering\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPart 1 — 프롬프트 구조와 기능 탐구\n\n\n\n\n\n\nAI\n\nLangChain\n\nPrompt_Engineering\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPart 1 — 프롬프트 구조와 기능 탐구\n\n\n\n\n\n\nAI\n\nLangChain\n\nPrompt_Engineering\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPart 1 — 프롬프트 구조와 기능 탐구\n\n\n\n\n\n\nAI\n\nLangChain\n\nPrompt_Engineering\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPart 1 — 프롬프트 구조와 기능 탐구\n\n\n\n\n\n\nAI\n\nLangChain\n\nPrompt_Engineering\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPart 1 — 프롬프트 구조와 기능 탐구\n\n\n\n\n\n\nAI\n\nLangChain\n\nPrompt_Engineering\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRAG\n\n\nRAG Content List\n\n\n\nAI\n\nLangChain\n\nRAG\n\n\n\nRetrieval-Augmented Generation (RAG) 기술의 전체 구현 과정을 다루는 종합 가이드. LangChain을 활용한 RAG 시스템 구축, 문서 로딩, 임베딩, 벡터 저장소, 검색기, 그리고 고급 RAG 기법까지 단계별로 학습할 수 있는 실습 중심의 블로그 모음입니다.\n\n\n\n\n\nNov 1, 2025\n\n\nJunhyun Lee\n\n\n\n\n\n\n\n\n\n\n\n\nPrompt_Engineering\n\n\nPrompt_Engineering Content List\n\n\n\nAI\n\nLangChain\n\nRAG\n\n\n\n\n\n\n\n\n\nNov 1, 2025\n\n\nJunhyun Lee\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Blog",
      "Blog Posts"
    ]
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/index.html",
    "href": "docs/blog/posts/Prompt_Engineering/index.html",
    "title": "Prompt_Engineering",
    "section": "",
    "text": "01-프롬프트 구조와 기능 탐구",
    "crumbs": [
      "Blog",
      "Blog Posts",
      "Prompt_Engineering"
    ]
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/index.html#prompt_engineering",
    "href": "docs/blog/posts/Prompt_Engineering/index.html#prompt_engineering",
    "title": "Prompt_Engineering",
    "section": "",
    "text": "01-프롬프트 구조와 기능 탐구",
    "crumbs": [
      "Blog",
      "Blog Posts",
      "Prompt_Engineering"
    ]
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화\n\n\n\n\n\nPromptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장\n\n\n\n\n\n\n\n\n\n\n\n\n항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#프롬프트의-정의",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#프롬프트의-정의",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "Promptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#개념",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#개념",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.1 2.1 개념",
    "text": "2.1 2.1 개념\n\n방대한 데이터 기반 사전학습 모델\nAutoregression: 이전 토큰 기반으로 다음 단어 예측\n기반 기술: Transformer 구조(셀프 어텐션)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#주요-모델-패밀리",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#주요-모델-패밀리",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.2 2.2 주요 모델 패밀리",
    "text": "2.2 2.2 주요 모델 패밀리\n\nOpenAI – GPT-4o: 멀티모달·실시간 처리\nAnthropic – Claude 3: 안전성 중점, 헌법적 AI\nGoogle – Gemini / BERT / T5: 다중 모달 처리"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#모델-튜닝-방식",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#모델-튜닝-방식",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.3 2.3 모델 튜닝 방식",
    "text": "2.3 2.3 모델 튜닝 방식\n\nFine-Tuning\nPrompt Engineering\nFeature-Tuning(특징 공간 해석 기반 제어)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#필수-4요소",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#필수-4요소",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.1 3.1 필수 4요소",
    "text": "3.1 3.1 필수 4요소\n\nInstruction: 어떤 작업을 해야 하는가\nContext: 배경 정보\nInput Data: 처리 대상 데이터\nOutput Indicator: 출력 형식 규정"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.2 3.2 프롬프트 타입 구조(Type A–D)",
    "text": "3.2 3.2 프롬프트 타입 구조(Type A–D)\n\nA: 지시문 + 출력문\nB: 지시문 + 맥락 + 출력문\nC: 지시문 + 맥락 + 예시 + 출력문\nD: 지시문 + 입력값 + 출력문\n\n예시와 함께 구조적으로 프롬프트를 설계하면 LLM이 더 안정적으로 원하는 출력 생성."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#대-원칙",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#대-원칙",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.1 4.1 4대 원칙",
    "text": "4.1 4.1 4대 원칙\n\n범용성: 다양한 상황에서도 동작\n목적 지향성: 특정 사용자 목적 반영\n일관성: 반복 실행해도 동일 품질\n경제성: API 비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#scaffolding-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#scaffolding-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.2 4.2 Scaffolding Prompting",
    "text": "4.2 4.2 Scaffolding Prompting\n\n인간의 학습 이론(ZPD)을 적용\nUnderstand → Ideation → Analysis → Apply → Evaluate → Generalize\n단계적 사고구조 유도"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#핵심-5-tips",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#핵심-5-tips",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.3 4.3 핵심 5 Tips",
    "text": "4.3 4.3 핵심 5 Tips\n\n4.3.1 Tip1. 최신 모델 사용\n\n\n4.3.2 Tip2. 명확한 동사로 지시\n예: 분석해, 정리해, 요약해, 작성해 등\n\n\n4.3.3 Tip 3. 프롬프트를 구조화하자\n프롬프트를 구조화하면 LLM이 입력을 더 명확하게 해석할 수 있고,\n작업 목적·규칙·입력 데이터·출력 형식을 혼동 없이 처리할 수 있다.\n구조화를 위한 핵심 기법은 Markdown, 코드 프롬프트, XML 태그이다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)",
    "text": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)\nMarkdown은 LLM이 가장 잘 해석하는 구조적 문법 중 하나이다.\n섹션을 명확히 나누고, 각 부분을 시각적으로 구분해줌으로써\n모델의 오류를 줄이고 반복 작업 시 유지보수성이 높아진다.\n\n4.4.1 1) 헤더(Headers) 활용\n헤더는 프롬프트의 구성을 크게 나누는 데 사용한다.\n# 역할(Role)\n너는 스포츠 기사 분석 엔진이다.\n\n## 작업(Task)\n아래 텍스트에서 장소(도시, 국가, 축구 클럽)를 모두 추출해라.\n\n## 출력 형식(Format)\n- \"장소: A, B, C\" 형태의 한 줄 출력\n- 설명 금지\n\n## 텍스트(Text)\n{{TEXT}}\n\n\n4.4.2 2) 목록(Lists) 활용\n절차, 규칙, 조건을 번호 목록으로 정리하면 LLM이 하나씩 적용하기 쉽다.\n다음 규칙을 따라 작업을 수행해라.\n1. 사람 이름은 제외한다.\n2. 축구 클럽은 장소로 포함한다.\n3. 결과는 쉼표로 구분한다.\n4. 설명 문장은 쓰지 않는다.\n\n\n4.4.3 3) 강조(Emphasis) 사용\n중요 조건을 굵게 또는 기울임으로 표시해 모델의 우선순위를 높인다.\n- 반드시 **한국어**로 작성하라.\n- 출력은 **한 줄**로만 작성한다.\n- *설명 문장은 포함하지 않는다.*"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.5 3.2 코드 프롬프트(Code Prompting)",
    "text": "4.5 3.2 코드 프롬프트(Code Prompting)\n자연어 대신 코드 형식으로 의도를 명세하면 애매함이 줄어들고 LLM이 구조적으로 이해해 할루시네이션이 감소한다.\n# 역할 정의\nrole = \"정보 추출 엔진\"\n\n# 작업 정의\ntask = \"텍스트에서 '장소명'을 추출해 정렬된 리스트로 반환\"\n\n# 출력 형식 정의\noutput = {\n    \"places\": [\"string\"]\n}\n코드 방식의 장점:\n\n논리 구조가 명확하게 표현됨\n조건과 출력 형식이 혼동되지 않음\n정형화된 포맷을 자주 재사용 가능"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)",
    "text": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)\nXML 태그는 텍스트 내 특정 영역을 명확히 구분해 Claude뿐 아니라 대부분의 LLM에서 구조적 파싱을 돕는 강력한 방식이다.\n\n4.6.1 1) 태그로 영역 지정\n&lt;email&gt;\nShow up at 6AM because I say so.\n&lt;/email&gt;\n\nMake this email more polite.\nLLM은 &lt;email&gt;...&lt;/email&gt; 내부 텍스트만 변환하면 된다는 것을 명확히 인식한다.\n\n\n4.6.2 2) 데이터 템플릿 예시\n&lt;animal&gt;{{ANIMAL}}&lt;/animal&gt;\n입력만 바꿔 여러 데이터를 동일한 템플릿에 적용할 수 있다.\n예:\n&lt;animal&gt;Cow&lt;/animal&gt;\n&lt;animal&gt;Dog&lt;/animal&gt;\n&lt;animal&gt;Seal&lt;/animal&gt;\n장점:\n\n구역별 의미가 명확\n반복 작업에서 수정이 쉽고 안정적\n모델이 태그 단위로 파싱하기 때문에 오류 감소"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.7 3.4 구조화 기법이 필요한 이유",
    "text": "4.7 3.4 구조화 기법이 필요한 이유\n\n명령어, 입력 데이터, 출력 형식을 명확히 구분해 모델의 해석 오류를 줄인다.\n규칙을 시각적으로 구분하여 작업 수행 품질의 일관성과 재현성을 높인다.\n재사용 가능한 템플릿이 되어 프롬프트 제작 비용과 시간 절감에 기여한다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.8 3.5 구조화 적용 사례 (장소명 추출)",
    "text": "4.8 3.5 구조화 적용 사례 (장소명 추출)\n# 역할(Role)\n너는 텍스트에서 장소명을 추출하는 엔진이다.\n\n## 작업(Task)\n텍스트 내 도시, 국가, 축구 클럽 이름을 모두 \"장소\"로 간주하고 추출해라.\n\n## 출력 형식(Format)\n- 한 줄로만 출력한다.\n- 형식: `장소: A, B, C`\n- 설명 문장 금지.\n\n## 텍스트(Text)\n음바페는 26일 쿠프 드 프랑스 프랑스컵 올랭피크 리옹과의\n결승전에서 풀타임을 뛰며 2-1로 팀 승리를 도왔다.\n3년 만에 대회 정상에 오른 PSG는 역대 최다 15회 우승으로\n2위 마르세유(10회)를 멀찍이 따돌렸다.\n음바페는 이날 PSG에서의 커리어를 마무리했다.\n\n4.8.1 Tip4. 단문 중심\n\n한국어는 짧고 명확하게 작성\n톤·형식·분량을 구체적으로 지시\n\n\n\n4.8.2 Tip5. 하지 말 것(X) → 할 것(O)\n\n부정 지시보다 긍정적 행동 지시가 안정적"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#llm-한계",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#llm-한계",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.1 5.1 LLM 한계",
    "text": "5.1 5.1 LLM 한계\n\n할루시네이션\n편향성\n근거 없는 출처 생성\n수학 및 추론 한계\nPrompt Injection(프롬프트 해킹)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 5/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유",
    "text": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유\n\n정확성 향상\n오류 및 편향 감소\n모델 행동 제어\n사용자 경험 개선\n비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화\n\n\n\n\n\nPromptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장\n\n\n\n\n\n\n\n\n\n\n\n\n항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#프롬프트의-정의",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#프롬프트의-정의",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "Promptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#개념",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#개념",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.1 2.1 개념",
    "text": "2.1 2.1 개념\n\n방대한 데이터 기반 사전학습 모델\nAutoregression: 이전 토큰 기반으로 다음 단어 예측\n기반 기술: Transformer 구조(셀프 어텐션)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#주요-모델-패밀리",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#주요-모델-패밀리",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.2 2.2 주요 모델 패밀리",
    "text": "2.2 2.2 주요 모델 패밀리\n\nOpenAI – GPT-4o: 멀티모달·실시간 처리\nAnthropic – Claude 3: 안전성 중점, 헌법적 AI\nGoogle – Gemini / BERT / T5: 다중 모달 처리"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#모델-튜닝-방식",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#모델-튜닝-방식",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.3 2.3 모델 튜닝 방식",
    "text": "2.3 2.3 모델 튜닝 방식\n\nFine-Tuning\nPrompt Engineering\nFeature-Tuning(특징 공간 해석 기반 제어)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#필수-4요소",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#필수-4요소",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.1 3.1 필수 4요소",
    "text": "3.1 3.1 필수 4요소\n\nInstruction: 어떤 작업을 해야 하는가\nContext: 배경 정보\nInput Data: 처리 대상 데이터\nOutput Indicator: 출력 형식 규정"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.2 3.2 프롬프트 타입 구조(Type A–D)",
    "text": "3.2 3.2 프롬프트 타입 구조(Type A–D)\n\nA: 지시문 + 출력문\nB: 지시문 + 맥락 + 출력문\nC: 지시문 + 맥락 + 예시 + 출력문\nD: 지시문 + 입력값 + 출력문\n\n예시와 함께 구조적으로 프롬프트를 설계하면 LLM이 더 안정적으로 원하는 출력 생성."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#대-원칙",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#대-원칙",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.1 4.1 4대 원칙",
    "text": "4.1 4.1 4대 원칙\n\n범용성: 다양한 상황에서도 동작\n목적 지향성: 특정 사용자 목적 반영\n일관성: 반복 실행해도 동일 품질\n경제성: API 비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#scaffolding-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#scaffolding-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.2 4.2 Scaffolding Prompting",
    "text": "4.2 4.2 Scaffolding Prompting\n\n인간의 학습 이론(ZPD)을 적용\nUnderstand → Ideation → Analysis → Apply → Evaluate → Generalize\n단계적 사고구조 유도"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#핵심-5-tips",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#핵심-5-tips",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.3 4.3 핵심 5 Tips",
    "text": "4.3 4.3 핵심 5 Tips\n\n4.3.1 Tip1. 최신 모델 사용\n\n\n4.3.2 Tip2. 명확한 동사로 지시\n예: 분석해, 정리해, 요약해, 작성해 등\n\n\n4.3.3 Tip 3. 프롬프트를 구조화하자\n프롬프트를 구조화하면 LLM이 입력을 더 명확하게 해석할 수 있고,\n작업 목적·규칙·입력 데이터·출력 형식을 혼동 없이 처리할 수 있다.\n구조화를 위한 핵심 기법은 Markdown, 코드 프롬프트, XML 태그이다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)",
    "text": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)\nMarkdown은 LLM이 가장 잘 해석하는 구조적 문법 중 하나이다.\n섹션을 명확히 나누고, 각 부분을 시각적으로 구분해줌으로써\n모델의 오류를 줄이고 반복 작업 시 유지보수성이 높아진다.\n\n4.4.1 1) 헤더(Headers) 활용\n헤더는 프롬프트의 구성을 크게 나누는 데 사용한다.\n# 역할(Role)\n너는 스포츠 기사 분석 엔진이다.\n\n## 작업(Task)\n아래 텍스트에서 장소(도시, 국가, 축구 클럽)를 모두 추출해라.\n\n## 출력 형식(Format)\n- \"장소: A, B, C\" 형태의 한 줄 출력\n- 설명 금지\n\n## 텍스트(Text)\n{{TEXT}}\n\n\n4.4.2 2) 목록(Lists) 활용\n절차, 규칙, 조건을 번호 목록으로 정리하면 LLM이 하나씩 적용하기 쉽다.\n다음 규칙을 따라 작업을 수행해라.\n1. 사람 이름은 제외한다.\n2. 축구 클럽은 장소로 포함한다.\n3. 결과는 쉼표로 구분한다.\n4. 설명 문장은 쓰지 않는다.\n\n\n4.4.3 3) 강조(Emphasis) 사용\n중요 조건을 굵게 또는 기울임으로 표시해 모델의 우선순위를 높인다.\n- 반드시 **한국어**로 작성하라.\n- 출력은 **한 줄**로만 작성한다.\n- *설명 문장은 포함하지 않는다.*"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.5 3.2 코드 프롬프트(Code Prompting)",
    "text": "4.5 3.2 코드 프롬프트(Code Prompting)\n자연어 대신 코드 형식으로 의도를 명세하면 애매함이 줄어들고 LLM이 구조적으로 이해해 할루시네이션이 감소한다.\n# 역할 정의\nrole = \"정보 추출 엔진\"\n\n# 작업 정의\ntask = \"텍스트에서 '장소명'을 추출해 정렬된 리스트로 반환\"\n\n# 출력 형식 정의\noutput = {\n    \"places\": [\"string\"]\n}\n코드 방식의 장점:\n\n논리 구조가 명확하게 표현됨\n조건과 출력 형식이 혼동되지 않음\n정형화된 포맷을 자주 재사용 가능"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)",
    "text": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)\nXML 태그는 텍스트 내 특정 영역을 명확히 구분해 Claude뿐 아니라 대부분의 LLM에서 구조적 파싱을 돕는 강력한 방식이다.\n\n4.6.1 1) 태그로 영역 지정\n&lt;email&gt;\nShow up at 6AM because I say so.\n&lt;/email&gt;\n\nMake this email more polite.\nLLM은 &lt;email&gt;...&lt;/email&gt; 내부 텍스트만 변환하면 된다는 것을 명확히 인식한다.\n\n\n4.6.2 2) 데이터 템플릿 예시\n&lt;animal&gt;{{ANIMAL}}&lt;/animal&gt;\n입력만 바꿔 여러 데이터를 동일한 템플릿에 적용할 수 있다.\n예:\n&lt;animal&gt;Cow&lt;/animal&gt;\n&lt;animal&gt;Dog&lt;/animal&gt;\n&lt;animal&gt;Seal&lt;/animal&gt;\n장점:\n\n구역별 의미가 명확\n반복 작업에서 수정이 쉽고 안정적\n모델이 태그 단위로 파싱하기 때문에 오류 감소"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.7 3.4 구조화 기법이 필요한 이유",
    "text": "4.7 3.4 구조화 기법이 필요한 이유\n\n명령어, 입력 데이터, 출력 형식을 명확히 구분해 모델의 해석 오류를 줄인다.\n규칙을 시각적으로 구분하여 작업 수행 품질의 일관성과 재현성을 높인다.\n재사용 가능한 템플릿이 되어 프롬프트 제작 비용과 시간 절감에 기여한다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.8 3.5 구조화 적용 사례 (장소명 추출)",
    "text": "4.8 3.5 구조화 적용 사례 (장소명 추출)\n# 역할(Role)\n너는 텍스트에서 장소명을 추출하는 엔진이다.\n\n## 작업(Task)\n텍스트 내 도시, 국가, 축구 클럽 이름을 모두 \"장소\"로 간주하고 추출해라.\n\n## 출력 형식(Format)\n- 한 줄로만 출력한다.\n- 형식: `장소: A, B, C`\n- 설명 문장 금지.\n\n## 텍스트(Text)\n음바페는 26일 쿠프 드 프랑스 프랑스컵 올랭피크 리옹과의\n결승전에서 풀타임을 뛰며 2-1로 팀 승리를 도왔다.\n3년 만에 대회 정상에 오른 PSG는 역대 최다 15회 우승으로\n2위 마르세유(10회)를 멀찍이 따돌렸다.\n음바페는 이날 PSG에서의 커리어를 마무리했다.\n\n4.8.1 Tip4. 단문 중심\n\n한국어는 짧고 명확하게 작성\n톤·형식·분량을 구체적으로 지시\n\n\n\n4.8.2 Tip5. 하지 말 것(X) → 할 것(O)\n\n부정 지시보다 긍정적 행동 지시가 안정적"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#llm-한계",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#llm-한계",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.1 5.1 LLM 한계",
    "text": "5.1 5.1 LLM 한계\n\n할루시네이션\n편향성\n근거 없는 출처 생성\n수학 및 추론 한계\nPrompt Injection(프롬프트 해킹)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 3/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유",
    "text": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유\n\n정확성 향상\n오류 및 편향 감소\n모델 행동 제어\n사용자 경험 개선\n비용 절감"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/03-Agent.html",
    "href": "docs/blog/posts/RAG/15-Agent/03-Agent.html",
    "title": "도구 호출 에이전트(Tool Calling Agent)",
    "section": "",
    "text": "도구 호출을 사용하면 모델이 하나 이상의 도구(tool) 가 호출되어야 하는 시기를 감지하고 해당 도구에 전달해야 하는 입력 으로 전달할 수 있습니다.\nAPI 호출에서 도구를 설명하고 모델이 이러한 도구를 호출하기 위한 인수가 포함된 JSON과 같은 구조화된 객체를 출력하도록 지능적으로 선택할 수 있습니다.\n도구 API 의 목표는 일반 텍스트 완성이나 채팅 API를 사용하여 수행할 수 있는 것보다 더 안정적으로 유효하고 유용한 도구 호출(tool call) 을 반환하는 것입니다.\n이러한 구조화된 출력을 도구 호출 채팅 모델에 여러 도구를 바인딩하고 모델이 호출할 도구를 선택할 수 있다는 사실과 결합하여 쿼리가 해결될 때까지 반복적으로 도구를 호출하고 결과를 수신하는 에이전트를 만들 수 있습니다.\n이것은 OpenAI 의 특정 도구 호출 스타일에 맞게 설계된 OpenAI 도구 에이전트의 보다 일반화된 버전 입니다.\n이 에이전트는 LangChain의 ToolCall 인터페이스를 사용하여 OpenAI 외에도 Anthropic, Google Gemini, Mistral과 같은 더 광범위한 공급자 구현을 지원합니다.\n참고 링크\n코드\n# API 키를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API 키 정보 로드\nload_dotenv()\n코드\n# LangSmith 추적을 설정합니다. https://smith.langchain.com\n# !pip install -qU langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력합니다.\nlogging.langsmith(\"CH15-Agents\")\n코드\nfrom langchain.tools import tool\nfrom typing import List, Dict, Annotated\nfrom langchain_teddynote.tools import GoogleNews\nfrom langchain_experimental.utilities import PythonREPL\n\n\n# 도구 생성\n@tool\ndef search_news(query: str) -&gt; List[Dict[str, str]]:\n    \"\"\"Search Google News by input keyword\"\"\"\n    news_tool = GoogleNews()\n    return news_tool.search_by_keyword(query, k=5)\n\n\n# 도구 생성\n@tool\ndef python_repl_tool(\n    code: Annotated[str, \"The python code to execute to generate your chart.\"],\n):\n    \"\"\"Use this to execute python code. If you want to see the output of a value,\n    you should print it out with `print(...)`. This is visible to the user.\"\"\"\n    result = \"\"\n    try:\n        result = PythonREPL().run(code)\n    except BaseException as e:\n        print(f\"Failed to execute. Error: {repr(e)}\")\n    finally:\n        return result\n\n\nprint(f\"도구 이름: {search_news.name}\")\nprint(f\"도구 설명: {search_news.description}\")\nprint(f\"도구 이름: {python_repl_tool.name}\")\nprint(f\"도구 설명: {python_repl_tool.description}\")\n코드\n# tools 정의\ntools = [search_news, python_repl_tool]"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/03-Agent.html#agent-프롬프트-생성",
    "href": "docs/blog/posts/RAG/15-Agent/03-Agent.html#agent-프롬프트-생성",
    "title": "도구 호출 에이전트(Tool Calling Agent)",
    "section": "1 Agent 프롬프트 생성",
    "text": "1 Agent 프롬프트 생성\n\nchat_history : 이전 대화 내용을 저장하는 변수 (멀티턴을 지원하지 않는다면, 생략 가능합니다.)\nagent_scratchpad : 에이전트가 임시로 저장하는 변수\ninput : 사용자의 입력\n\n\n\n코드\nfrom langchain_core.prompts import ChatPromptTemplate\n\n# 프롬프트 생성\n# 프롬프트는 에이전트에게 모델이 수행할 작업을 설명하는 텍스트를 제공합니다. (도구의 이름과 역할을 입력)\nprompt = ChatPromptTemplate.from_messages(\n    [\n        (\n            \"system\",\n            \"You are a helpful assistant. \"\n            \"Make sure to use the `search_news` tool for searching keyword related news.\",\n        ),\n        (\"placeholder\", \"{chat_history}\"),\n        (\"human\", \"{input}\"),\n        (\"placeholder\", \"{agent_scratchpad}\"),\n    ]\n)"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/03-Agent.html#agent-생성",
    "href": "docs/blog/posts/RAG/15-Agent/03-Agent.html#agent-생성",
    "title": "도구 호출 에이전트(Tool Calling Agent)",
    "section": "2 Agent 생성",
    "text": "2 Agent 생성\n\n\n코드\nfrom langchain_openai import ChatOpenAI\nfrom langchain.agents import create_tool_calling_agent\n\n# LLM 정의\nllm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)\n\n# Agent 생성\nagent = create_tool_calling_agent(llm, tools, prompt)"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/03-Agent.html#agentexecutor",
    "href": "docs/blog/posts/RAG/15-Agent/03-Agent.html#agentexecutor",
    "title": "도구 호출 에이전트(Tool Calling Agent)",
    "section": "3 AgentExecutor",
    "text": "3 AgentExecutor\nAgentExecutor는 도구를 사용하는 에이전트를 실행하는 클래스입니다.\n주요 속성 - agent: 실행 루프의 각 단계에서 계획을 생성하고 행동을 결정하는 에이전트 - tools: 에이전트가 사용할 수 있는 유효한 도구 목록 - return_intermediate_steps: 최종 출력과 함께 에이전트의 중간 단계 경로를 반환할지 여부 - max_iterations: 실행 루프를 종료하기 전 최대 단계 수 - max_execution_time: 실행 루프에 소요될 수 있는 최대 시간 - early_stopping_method: 에이전트가 AgentFinish를 반환하지 않을 때 사용할 조기 종료 방법. (“force” or “generate”) - \"force\" 는 시간 또는 반복 제한에 도달하여 중지되었다는 문자열을 반환합니다. - \"generate\" 는 에이전트의 LLM 체인을 마지막으로 한 번 호출하여 이전 단계에 따라 최종 답변을 생성합니다. - handle_parsing_errors: 에이전트의 출력 파서에서 발생한 오류 처리 방법. (True, False, 또는 오류 처리 함수) - trim_intermediate_steps: 중간 단계를 트리밍하는 방법. (-1 trim 하지 않음, 또는 트리밍 함수)\n주요 메서드 1. invoke: 에이전트 실행 2. stream: 최종 출력에 도달하는 데 필요한 단계를 스트리밍\n주요 기능 1. 도구 검증: 에이전트와 호환되는 도구인지 확인 2. 실행 제어: 최대 반복 횟수 및 실행 시간 제한 설정 가능 3. 오류 처리: 출력 파싱 오류에 대한 다양한 처리 옵션 제공 4. 중간 단계 관리: 중간 단계 트리밍 및 반환 옵션 5. 비동기 지원: 비동기 실행 및 스트리밍 지원\n최적화 팁 - max_iterations와 max_execution_time을 적절히 설정하여 실행 시간 관리 - trim_intermediate_steps를 활용하여 메모리 사용량 최적화 - 복잡한 작업의 경우 stream 메서드를 사용하여 단계별 결과 모니터링\n\n\n코드\nfrom langchain.agents import AgentExecutor\n\n# AgentExecutor 생성\nagent_executor = AgentExecutor(\n    agent=agent,\n    tools=tools,\n    verbose=True,\n    max_iterations=10,\n    max_execution_time=10,\n    handle_parsing_errors=True,\n)\n\n# AgentExecutor 실행\nresult = agent_executor.invoke({\"input\": \"AI 투자와 관련된 뉴스를 검색해 주세요.\"})\n\nprint(\"Agent 실행 결과:\")\nprint(result[\"output\"])"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/03-Agent.html#stream-출력으로-단계별-결과-확인",
    "href": "docs/blog/posts/RAG/15-Agent/03-Agent.html#stream-출력으로-단계별-결과-확인",
    "title": "도구 호출 에이전트(Tool Calling Agent)",
    "section": "4 Stream 출력으로 단계별 결과 확인",
    "text": "4 Stream 출력으로 단계별 결과 확인\nAgentExecutor의 stream() 메소드를 사용하여 에이전트의 중간 단계를 스트리밍할 것입니다.\nstream()의 출력은 (Action, Observation) 쌍 사이에서 번갈아 나타나며, 최종적으로 에이전트가 목표를 달성했다면 답변으로 마무리됩니다.\n다음과 같은 형태로 보일 것입니다.\n\nAction 출력\nObservation 출력\nAction 출력\nObservation 출력\n\n… (목표 달성까지 계속) …\n그 다음, 최종 목표가 달성되면 에이전트는 최종 답변을 출력할 것입니다.\n이러한 출력의 내용은 다음과 같이 요약됩니다.\n\n\n\n\n\n\n\n출력\n내용\n\n\n\n\nAction\nactions: AgentAction 또는 그 하위 클래스messages: 액션 호출에 해당하는 채팅 메시지\n\n\nObservation\nsteps: 현재 액션과 그 관찰을 포함한 에이전트가 지금까지 수행한 작업의 기록messages: 함수 호출 결과(즉, 관찰)를 포함한 채팅 메시지\n\n\nFinal Answer\noutput: AgentFinishmessages: 최종 출력을 포함한 채팅 메시지\n\n\n\n\n::: {#bf7b4031 .cell execution_count=8}\n``` {.python .cell-code}\nfrom langchain.agents import AgentExecutor\n\n# AgentExecutor 생성\nagent_executor = AgentExecutor(\n    agent=agent,\n    tools=tools,\n    verbose=False,\n    handle_parsing_errors=True,\n)\n:::\n\n\n코드\n# 스트리밍 모드로 실행합니다\nresult = agent_executor.stream({\"input\": \"AI 투자와 관련된 뉴스를 검색해 주세요.\"})\n\nfor step in result:\n    # 중간 단계 출력\n    print(step)\n    print(\"===\" * 20)\n\n\n\n4.1 중간 단계 출력을 사용자 정의 함수로 출력\n다음의 3개 함수를 정의하고 이를 통해 중간 단계 출력을 사용자 정의합니다.\n\ntool_callback: 도구 호출 출력을 처리하는 함수\nobservation_callback: 관찰(Observation) 출력을 처리하는 함수\nresult_callback: 최종 답변 출력을 처리하는 함수\n\n\n\n코드\n# 업데이트\n# !pip install -U langchain-teddynote\n\n\n아래는 Agent 의 중간 단계 과정을 깔끔하게 출력하기 위하여 사용되는 콜백 함수입니다.\n이 콜백 함수는 Streamlit 에서 중간 단계를 출력하여 사용자에게 제공할 때 유용할 수 있습니다.\n\n\n코드\nfrom langchain_teddynote.messages import AgentStreamParser\n\nagent_stream_parser = AgentStreamParser()\n\n\n스트리밍 방식으로 Agent 의 응답 과정을 확인합니다.\n\n\n코드\n# 질의에 대한 답변을 스트리밍으로 출력 요청\nresult = agent_executor.stream(\n    {\"input\": \"matplotlib 을 사용하여 pie 차트를 그리는 코드를 작성하고 실행하세요.\"}\n)\n\nfor step in result:\n    # 중간 단계를 parser 를 사용하여 단계별로 출력\n    # print(step)\n    agent_stream_parser.process_agent_steps(step)\n\n\n다음은 callback 을 수정하여 사용하는 방법입니다.\n\n\n코드\n# AgentCallbacks와 AgentStreamParser를 langchain_teddynote.messages에서 가져옵니다.\nfrom langchain_teddynote.messages import AgentCallbacks, AgentStreamParser\n\n\n# 도구 호출 시 실행되는 콜백 함수입니다.\ndef tool_callback(tool) -&gt; None:\n    print(\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; 도구 호출 &gt;&gt;&gt;&gt;&gt;&gt;\")\n    print(f\"Tool: {tool.get('tool')}\")  # 사용된 도구의 이름을 출력합니다.\n    print(\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; 도구 호출 &gt;&gt;&gt;&gt;&gt;&gt;\")\n\n\n# 관찰 결과를 출력하는 콜백 함수입니다.\ndef observation_callback(observation) -&gt; None:\n    print(\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; 관찰 내용 &gt;&gt;&gt;&gt;&gt;&gt;\")\n    print(\n        f\"Observation: {observation.get('observation')[0]}\"\n    )  # 관찰 내용을 출력합니다.\n    print(\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; 관찰 내용 &gt;&gt;&gt;&gt;&gt;&gt;\")\n\n\n# 최종 결과를 출력하는 콜백 함수입니다.\ndef result_callback(result: str) -&gt; None:\n    print(\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; 최종 답변 &gt;&gt;&gt;&gt;&gt;&gt;\")\n    print(result)  # 최종 답변을 출력합니다.\n    print(\"&lt;&lt;&lt;&lt;&lt;&lt;&lt; 최종 답변 &gt;&gt;&gt;&gt;&gt;&gt;\")\n\n\n# AgentCallbacks 객체를 생성하여 각 단계별 콜백 함수를 설정합니다.\nagent_callbacks = AgentCallbacks(\n    tool_callback=tool_callback,\n    observation_callback=observation_callback,\n    result_callback=result_callback,\n)\n\n# AgentStreamParser 객체를 생성하여 에이전트의 실행 과정을 파싱합니다.\nagent_stream_parser = AgentStreamParser(agent_callbacks)\n\n\n아래의 출력 내용을 확인해 보면 중간 내용의 출력 값이 내가 변경한 콜백 함수의 출력 값으로 변경된 것을 확인할 수 있습니다.\n\n\n코드\n# 질의에 대한 답변을 스트리밍으로 출력 요청\nresult = agent_executor.stream({\"input\": \"AI 투자관련 뉴스를 검색해 주세요.\"})\n\nfor step in result:\n    # 중간 단계를 parser 를 사용하여 단계별로 출력\n    agent_stream_parser.process_agent_steps(step)"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/03-Agent.html#이전-대화내용-기억하는-agent",
    "href": "docs/blog/posts/RAG/15-Agent/03-Agent.html#이전-대화내용-기억하는-agent",
    "title": "도구 호출 에이전트(Tool Calling Agent)",
    "section": "5 이전 대화내용 기억하는 Agent",
    "text": "5 이전 대화내용 기억하는 Agent\n이전의 대화내용을 기억하기 위해서는 RunnableWithMessageHistory 를 사용하여 AgentExecutor 를 감싸줍니다.\nRunnableWithMessageHistory 에 대한 자세한 내용은 아래 링크를 참고해 주세요.\n참고 - RunnableWithMessageHistory\n\n\n코드\nfrom langchain_community.chat_message_histories import ChatMessageHistory\nfrom langchain_core.runnables.history import RunnableWithMessageHistory\n\n# session_id 를 저장할 딕셔너리 생성\nstore = {}\n\n\n# session_id 를 기반으로 세션 기록을 가져오는 함수\ndef get_session_history(session_ids):\n    if session_ids not in store:  # session_id 가 store에 없는 경우\n        # 새로운 ChatMessageHistory 객체를 생성하여 store에 저장\n        store[session_ids] = ChatMessageHistory()\n    return store[session_ids]  # 해당 세션 ID에 대한 세션 기록 반환\n\n\n# 채팅 메시지 기록이 추가된 에이전트를 생성합니다.\nagent_with_chat_history = RunnableWithMessageHistory(\n    agent_executor,\n    # 대화 session_id\n    get_session_history,\n    # 프롬프트의 질문이 입력되는 key: \"input\"\n    input_messages_key=\"input\",\n    # 프롬프트의 메시지가 입력되는 key: \"chat_history\"\n    history_messages_key=\"chat_history\",\n)\n\n\n\n\n코드\n# 질의에 대한 답변을 스트리밍으로 출력 요청\nresponse = agent_with_chat_history.stream(\n    {\"input\": \"안녕? 내 이름은 테디야!\"},\n    # session_id 설정\n    config={\"configurable\": {\"session_id\": \"abc123\"}},\n)\n\n# 출력 확인\nfor step in response:\n    agent_stream_parser.process_agent_steps(step)\n\n\n\n\n코드\n# 질의에 대한 답변을 스트리밍으로 출력 요청\nresponse = agent_with_chat_history.stream(\n    {\"input\": \"내 이름이 뭐라고?\"},\n    # session_id 설정\n    config={\"configurable\": {\"session_id\": \"abc123\"}},\n)\n\n# 출력 확인\nfor step in response:\n    agent_stream_parser.process_agent_steps(step)\n\n\n\n\n코드\n# 질의에 대한 답변을 스트리밍으로 출력 요청\nresponse = agent_with_chat_history.stream(\n    {\n        \"input\": \"내 이메일 주소는 teddy@teddynote.com 이야. 회사 이름은 테디노트 주식회사야.\"\n    },\n    # session_id 설정\n    config={\"configurable\": {\"session_id\": \"abc123\"}},\n)\n\n# 출력 확인\nfor step in response:\n    agent_stream_parser.process_agent_steps(step)\n\n\n\n\n코드\n# 질의에 대한 답변을 스트리밍으로 출력 요청\nresponse = agent_with_chat_history.stream(\n    {\n        \"input\": \"최신 뉴스 5개를 검색해서 이메일의 본문으로 작성해줘. \"\n        \"수신인에는 `셜리 상무님` 그리고, 발신인에는 내 인적정보를 적어줘.\"\n        \"정중한 어조로 작성하고, 메일의 시작과 끝에는 적절한 인사말과 맺음말을 적어줘.\"\n    },\n    # session_id 설정\n    config={\"configurable\": {\"session_id\": \"abc123\"}},\n)\n\n# 출력 확인\nfor step in response:\n    agent_stream_parser.process_agent_steps(step)\n\n\n\n\n코드\n# 질의에 대한 답변을 스트리밍으로 출력 요청\nresponse = agent_with_chat_history.stream(\n    {\n        \"input\": \"내 이름이 뭐야?\"\n    },\n    # session_id 설정\n    config={\"configurable\": {\"session_id\": \"def456\"}},\n)\n\n# 출력 확인\nfor step in response:\n    agent_stream_parser.process_agent_steps(step)"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/05-Iter-Human-In-the-Loop.html",
    "href": "docs/blog/posts/RAG/15-Agent/05-Iter-Human-In-the-Loop.html",
    "title": "Iteration 기능과 사람 개입(Human-in-the-loop)",
    "section": "",
    "text": "iter() 메서드는 에이전트의 실행 과정을 단계별로 반복할 수 있게 해주는 반복자(iterator)를 생성합니다.\n중간 과정에서 사용자의 입력을 받아 계속 진행할지 묻는 기능을 제공합니다. 이를 Human-in-the-loop 라고 합니다.\n\n\n코드\n# API KEY를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API KEY 정보로드\nload_dotenv()\n\n\n\n\n코드\n# LangSmith 추적을 설정합니다. https://smith.langchain.com\n# !pip install -qU langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력합니다.\nlogging.langsmith(\"CH15-Agents\")\n\n\n먼저, 도구(tool) 를 정의합니다.\n\n\n코드\nfrom langchain.agents import tool\n\n\n@tool\ndef add_function(a: float, b: float) -&gt; float:\n    \"\"\"Adds two numbers together.\"\"\"\n    return a + b\n\n\n다음으로는 add_function 을 사용하여 덧셈 계산을 수행하는 Agent 를 정의합니다.\n\n\n코드\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder\nfrom langchain_openai import ChatOpenAI\nfrom langchain.agents import create_tool_calling_agent, AgentExecutor\n\n# 도구 정의\ntools = [add_function]\n\n# LLM 생성\ngpt = ChatOpenAI(model=\"gpt-4o-mini\")\n\n# prompt 생성\nprompt = ChatPromptTemplate.from_messages(\n    [\n        (\n            \"system\",\n            \"You are a helpful assistant.\",\n        ),\n        (\"human\", \"{input}\"),\n        MessagesPlaceholder(variable_name=\"agent_scratchpad\"),\n    ]\n)\n\n# Agent 생성\ngpt_agent = create_tool_calling_agent(gpt, tools, prompt)\n\n# AgentExecutor 생성\nagent_executor = AgentExecutor(\n    agent=gpt_agent,\n    tools=tools,\n    verbose=False,\n    max_iterations=10,\n    handle_parsing_errors=True,\n)\n\n\n\n0.1 AgentExecutor의 iter()\n이 메서드는 AgentExecutor의 실행 과정을 단계별로 반복할 수 있게 해주는 반복자(iterator)를 생성합니다.\n함수 설명 iter() 는 에이전트가 최종 출력에 도달하기까지 거치는 단계들을 순차적으로 접근할 수 있는 AgentExecutorIterator 객체를 반환합니다.\n주요 기능 - 단계별 실행 접근: 에이전트의 실행 과정을 단계별로 살펴볼 수 있습니다.\n흐름 정리\n\"114.5 + 121.2 + 34.2 + 110.1\" 의 덧셈 계산을 수행하기 위해서는 단계별로 계산이 수행되게 됩니다.\n\n114.5 + 121.2 = 235.7\n235.7 + 34.2 = 270.9\n270.9 + 110.1 = 381.0\n\n이러한 계산 과정을 단계별로 살펴볼 수 있습니다.\n이때,\n단계별로 계산 결과를 사용자에게 보여주고, 사용자가 계속 진행할지 묻습니다. (Human-in-the-loop)\n사용자가 ’y’가 아닌 다른 입력을 하면 반복 중단됩니다.\n\n\n코드\n# 계산할 질문 설정\nquestion = \"114.5 + 121.2 + 34.2 + 110.1 의 계산 결과는?\"\n\n# agent_executor를 반복적으로 실행\nfor step in agent_executor.iter({\"input\": question}):\n    if output := step.get(\"intermediate_step\"):\n        action, value = output[0]\n        if action.tool == \"add_function\":\n            # Tool 실행 결과 출력\n            print(f\"\\nTool Name: {action.tool}, 실행 결과: {value}\")\n        # 사용자에게 계속 진행할지 묻습니다.\n        _continue = input(\"계속 진행하시겠습니다? (y/n)?:\\n\") or \"Y\"\n        # 사용자가 'y'가 아닌 다른 입력을 하면 반복 중단\n        if _continue.lower() != \"y\":\n            break\n\n# 최종 결과 출력\nif \"output\" in step:\n    print(step[\"output\"])"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/04-Agent-More-LLMs.html",
    "href": "docs/blog/posts/RAG/15-Agent/04-Agent-More-LLMs.html",
    "title": "OpenAI 외 도구 호출 에이전트(Tool Calling Agent)",
    "section": "",
    "text": "OpenAI 외에도 Anthropic, Google Gemini, Together.ai, Ollama, Mistral과 같은 더 광범위한 공급자 구현을 지원합니다.\n이번 챕터에서는 다양한 LLM 을 사용하여 도구 호출 에이전트를 생성하고 실행하는 방법을 살펴보겠습니다.\n참고 링크\n코드\n# API 키를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API 키 정보 로드\nload_dotenv()\n코드\n# LangSmith 추적을 설정합니다. https://smith.langchain.com\n# !pip install -qU langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력합니다.\nlogging.langsmith(\"CH15-Agents\")\n코드\nfrom langchain.tools import tool\nfrom typing import List, Dict\nfrom langchain_teddynote.tools import GoogleNews\n\n\n# 도구 정의\n@tool\ndef search_news(query: str) -&gt; List[Dict[str, str]]:\n    \"\"\"Search Google News by input keyword\"\"\"\n    news_tool = GoogleNews()\n    return news_tool.search_by_keyword(query, k=5)\n\n\nprint(f\"도구 이름: {search_news.name}\")\nprint(f\"도구 설명: {search_news.description}\")\n코드\n# tools 정의\ntools = [search_news]"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/04-Agent-More-LLMs.html#agent-용-프롬프트-생성",
    "href": "docs/blog/posts/RAG/15-Agent/04-Agent-More-LLMs.html#agent-용-프롬프트-생성",
    "title": "OpenAI 외 도구 호출 에이전트(Tool Calling Agent)",
    "section": "1 Agent 용 프롬프트 생성",
    "text": "1 Agent 용 프롬프트 생성\n\nchat_history : 이전 대화 내용을 저장하는 변수 (멀티턴을 지원하지 않는다면, 생략 가능합니다.)\nagent_scratchpad : 에이전트가 임시로 저장하는 변수\ninput : 사용자의 입력\n\n\n\n코드\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain.agents import create_tool_calling_agent\n\n# 프롬프트 생성\n# 프롬프트는 에이전트에게 모델이 수행할 작업을 설명하는 텍스트를 제공합니다. (도구의 이름과 역할을 입력)\nprompt = ChatPromptTemplate.from_messages(\n    [\n        (\n            \"system\",\n            \"You are a helpful assistant. \"\n            \"Make sure to use the `search_news` tool for searching keyword related news.\",\n        ),\n        (\"placeholder\", \"{chat_history}\"),\n        (\"human\", \"{input}\"),\n        (\"placeholder\", \"{agent_scratchpad}\"),\n    ]\n)"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/04-Agent-More-LLMs.html#tool-calling-을-지원하는-다양한-llm-목록",
    "href": "docs/blog/posts/RAG/15-Agent/04-Agent-More-LLMs.html#tool-calling-을-지원하는-다양한-llm-목록",
    "title": "OpenAI 외 도구 호출 에이전트(Tool Calling Agent)",
    "section": "2 Tool Calling 을 지원하는 다양한 LLM 목록",
    "text": "2 Tool Calling 을 지원하는 다양한 LLM 목록\n실습 진행을 위해서는 아래 내용을 설정해야 합니다.\nAnthropic\n\nAnthropic API 키 발급 관련\n.env 파일 내 ANTHROPIC_API_KEY 에 발급받은 키를 설정하세요\n\nGemini\n\nGemini API 키 발급 관련\n.env 파일 내 GOOGLE_API_KEY 에 발급받은 키를 설정하세요\n\nTogether AI\n\nTogether AI API 키 발급 관련\n.env 파일 내 TOGETHER_API_KEY 에 발급받은 키를 설정하세요\n\nOllama\n\nOllama Tool Calling 지원 모델 리스트\n이번 실습에 사용할 llama3.1 모델\n터미널 창에 ollama pull llama3.1 명령어를 입력하여 모델을 다운로드 받습니다.\n이전에 Ollama 를 사용하지 않았다면, Ollama 를 참고해 주세요.\n\nlangchain-ollama 설치를 한 뒤 진행해 주세요.\n\n\n코드\n# !pip install -qU langchain-ollama==0.1.3\n\n\n\n\n코드\nfrom langchain_anthropic import ChatAnthropic\nfrom langchain_google_genai import ChatGoogleGenerativeAI\nfrom langchain_openai import ChatOpenAI\nfrom langchain_ollama import ChatOllama\nimport os\n\n# GPT-4o-mini\ngpt = ChatOpenAI(model=\"gpt-4o-mini\")\n\n# Claude-3-5-sonnet\nclaude = ChatAnthropic(model=\"claude-3-5-sonnet-20240620\", temperature=0)\n\n# Gemini-1.5-pro-latest\ngemini = ChatGoogleGenerativeAI(model=\"gemini-1.5-pro\", temperature=0)\n\n# Llama-3.1-70B-Instruct-Turbo\nllama = ChatOpenAI(\n    base_url=\"https://api.together.xyz/v1\",\n    api_key=os.environ[\"TOGETHER_API_KEY\"],\n    model=\"meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo\",\n)\n\n# Llama-3.1\nollama = ChatOllama(model=\"llama3.1\", temperature=0)\n\n# Qwen2.5 7B (한글 성능 괜찮은 편)\nqwen = ChatOllama(\n    model=\"qwen2.5:latest\",\n)\n\n\nLLM 기반으로 Agent 를 생성합니다.\n\n\n코드\nfrom langchain.agents import create_tool_calling_agent\n\n# Agent 생성\ngpt_agent = create_tool_calling_agent(gpt, tools, prompt)\nclaude_agent = create_tool_calling_agent(claude, tools, prompt)\ngemini_agent = create_tool_calling_agent(gemini, tools, prompt)\nllama_agent = create_tool_calling_agent(llama, tools, prompt)\nollama_agent = create_tool_calling_agent(ollama, tools, prompt)\nqwen_agent = create_tool_calling_agent(qwen, tools, prompt)"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/04-Agent-More-LLMs.html#agentexecutor-생성-후-실행-및-결과-확인",
    "href": "docs/blog/posts/RAG/15-Agent/04-Agent-More-LLMs.html#agentexecutor-생성-후-실행-및-결과-확인",
    "title": "OpenAI 외 도구 호출 에이전트(Tool Calling Agent)",
    "section": "3 AgentExecutor 생성 후 실행 및 결과 확인",
    "text": "3 AgentExecutor 생성 후 실행 및 결과 확인\n\n\n코드\nfrom langchain.agents import AgentExecutor\n\n# gpt_agent 실행\nagent_executor = AgentExecutor(\n    agent=gpt_agent,\n    tools=tools,\n    verbose=True,\n    handle_parsing_errors=True,\n)\n\nresult = agent_executor.invoke({\"input\": \"AI 투자와 관련된 뉴스를 검색해 주세요.\"})\n\nprint(\"Agent 실행 결과:\")\nprint(result[\"output\"])\n\n\n다양한 llm을 사용하여 에이전트를 실행합니다.\n다음은 입력받은 llm을 사용하여 Agent 를 생성하고 실행하여 결과를 출력하는 함수입니다.\n\n\n코드\ndef execute_agent(llm, tools, input_text, label):\n    agent = create_tool_calling_agent(llm, tools, prompt)\n    executor = AgentExecutor(agent=agent, tools=tools, verbose=False)\n    result = executor.invoke({\"input\": input_text})\n    print(f\"[{label}] 결과입니다.\")\n    if isinstance(result[\"output\"], list) and len(result[\"output\"]) &gt; 0:\n        for item in result[\"output\"]:\n            if \"text\" in item:\n                print(item[\"text\"])\n    elif isinstance(result[\"output\"], str):\n        print(result[\"output\"])\n    else:\n        print(result[\"output\"])\n\n\n각 llm 별로 에이전트를 생성하고 실행하여 결과를 출력합니다.\n\n\n코드\nquery = (\n    \"AI 투자와 관련된 뉴스를 검색하고, 결과를 Instagram 게시글 형식으로 작성해 주세요.\"\n)\n\n\n\n\n코드\n# gpt\nexecute_agent(gpt, tools, query, \"gpt\")\n\n\n\n\n코드\n# claude\nexecute_agent(claude, tools, query, \"claude\")\n\n\n\n\n코드\n# gemini\nexecute_agent(gemini, tools, query, \"gemini\")\n\n\n\n\n코드\n# llama3.1 70B (Together.ai)\nexecute_agent(\n    llama,\n    tools,\n    \"Search AI related news and write it in Instagram post format\",\n    \"llama3.1 70B\",\n)\n\n\n\n\n코드\n# llama3.1 8B (ollama)\nexecute_agent(ollama, tools, query, \"llama3.1(Ollama)\")\n\n\n\n\n코드\n# qwen2.5 7B (ollama)\nquery = \"AI 투자와 관련된 뉴스를 검색하고, 결과를 Instagram 게시글 형식으로 작성해 주세요. 한글로 답변하세요!\"\n\nexecute_agent(qwen, tools, query, \"qwen2.5(Ollama)\")"
  },
  {
    "objectID": "docs/blog/posts/RAG/index.html",
    "href": "docs/blog/posts/RAG/index.html",
    "title": "RAG",
    "section": "",
    "text": "01-Tools\n02-Bind-Tools\n03-Agent\n04-Agent-More-LLMs\n05-Iter-Human-In-the-Loop",
    "crumbs": [
      "Blog",
      "Blog Posts",
      "RAG"
    ]
  },
  {
    "objectID": "docs/blog/posts/RAG/index.html#rag",
    "href": "docs/blog/posts/RAG/index.html#rag",
    "title": "RAG",
    "section": "",
    "text": "01-Tools\n02-Bind-Tools\n03-Agent\n04-Agent-More-LLMs\n05-Iter-Human-In-the-Loop",
    "crumbs": [
      "Blog",
      "Blog Posts",
      "RAG"
    ]
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/01-Tools.html",
    "href": "docs/blog/posts/RAG/15-Agent/01-Tools.html",
    "title": "도구 (Tools)",
    "section": "",
    "text": "도구(Tool)는 에이전트, 체인 또는 LLM이 외부 세계와 상호작용하기 위한 인터페이스입니다.\nLangChain 에서 기본 제공하는 도구를 사용하여 쉽게 도구를 활용할 수 있으며, 사용자 정의 도구(Custom Tool) 를 쉽게 구축하는 것도 가능합니다.\nLangChain 에 통합된 도구 리스트는 아래 링크에서 확인할 수 있습니다.\n코드\n# API 키를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API 키 정보 로드\nload_dotenv()\n코드\n# LangSmith 추적을 설정합니다. https://smith.langchain.com\n# !pip install -qU langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력합니다.\nlogging.langsmith(\"CH15-Tools\")\n코드\nimport warnings\n\n# 경고 메시지 무시\nwarnings.filterwarnings(\"ignore\")"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/01-Tools.html#빌트인-도구built-in-tools",
    "href": "docs/blog/posts/RAG/15-Agent/01-Tools.html#빌트인-도구built-in-tools",
    "title": "도구 (Tools)",
    "section": "1 빌트인 도구(built-in tools)",
    "text": "1 빌트인 도구(built-in tools)\n랭체인에서 제공하는 사전에 정의된 도구(tool) 와 툴킷(toolkit) 을 사용할 수 있습니다.\ntool 은 단일 도구를 의미하며, toolkit 은 여러 도구를 묶어서 하나의 도구로 사용할 수 있습니다.\n관련 도구는 아래의 링크에서 참고하실 수 있습니다.\n참고 - LangChain Tools/Toolkits\n\n1.1 Python REPL 도구\n이 도구는 Python 코드를 REPL(Read-Eval-Print Loop) 환경에서 실행하기 위한 클래스를 제공합니다 어떤 코드를 만들어서 실행하는 것이다. - PythonREPLTool\n설명\n\nPython 셸 환경을 제공합니다.\n유효한 Python 명령어를 입력으로 받아 실행합니다.\n결과를 보려면 print(…) 함수를 사용해야 합니다.\n\n주요 특징\n\nsanitize_input: 입력을 정제하는 옵션 (기본값: True)\npython_repl: PythonREPL 인스턴스 (기본값: 전역 범위에서 실행)\n\n사용 방법\n\nPythonREPLTool 인스턴스 생성\nrun 또는 arun, invoke 메서드를 사용하여 Python 코드 실행\n\n입력 정제\n\n입력 문자열에서 불필요한 공백, 백틱, ‘python’ 키워드 등을 제거합니다.\n\n\n\n코드\nfrom langchain_experimental.tools import PythonREPLTool\n\n# 파이썬 코드를 실행하는 도구를 생성합니다.\npython_tool = PythonREPLTool()\n\n\n\n\n코드\n# 파이썬 코드를 실행하고 결과를 반환합니다.\nprint(python_tool.invoke(\"print(100 + 200)\"))\n\n\n아래는 LLM 에게 파이썬 코드를 작성하도록 요청하고 결과를 반환하는 예제입니다.\n흐름 정리 1. LLM 모델에게 특정 작업을 수행하는 Python 코드를 작성하도록 요청합니다. 2. 작성된 코드를 실행하여 결과를 얻습니다. 3. 결과를 출력합니다.\n\n\n코드\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_core.runnables import RunnableLambda\n\n\n# 파이썬 코드를 실행하고 중간 과정을 출력하고 도구 실행 결과를 반환하는 함수\ndef print_and_execute(code, debug=False):\n    if debug:\n        print(\"CODE:\")\n        print(code)\n    return python_tool.invoke(code)\n\n\n# 파이썬 코드를 작성하도록 요청하는 프롬프트\nprompt = ChatPromptTemplate.from_messages(\n    [\n        (\n            \"system\",\n            \"You are Raymond Hetting, an expert python programmer, well versed in meta-programming and elegant, concise and short but well documented code. You follow the PEP8 style guide. \"\n            \"Return only the code, no intro, no explanation, no chatty, no markdown, no code block, no nothing. Just the code.\",\n        ),\n        (\"human\", \"{input}\"),\n    ]\n)\n# LLM 모델 생성\nllm = ChatOpenAI(model=\"gpt-4o\", temperature=0)\n\n# 프롬프트와 LLM 모델을 사용하여 체인 생성\nchain = prompt | llm | StrOutputParser() | RunnableLambda(print_and_execute)\n\n\n\n\n코드\n# 결과 출력\nprint(chain.invoke(\"로또 번호 생성기를 출력하는 코드를 작성하세요.\"))\n\n\n\n\n1.2 검색 API 도구\nTavily 검색 API를 활용하여 검색 기능을 구현하는 도구입니다. 이 도구는 두 가지 주요 클래스를 제공합니다: TavilySearchResults와 TavilyAnswer.\nAPI 키 발급 주소 - https://app.tavily.com/\n발급한 API 키를 환경변수에 설정합니다.\n.env 파일에 아래와 같이 설정합니다.\nTAVILY_API_KEY=tvly-abcdefghijklmnopqrstuvwxyz\n\n\n1.3 TavilySearchResults\n설명 - Tavily 검색 API를 쿼리하고 JSON 형식의 결과를 반환합니다. - 포괄적이고 정확하며 신뢰할 수 있는 결과에 최적화된 검색 엔진입니다. - 현재 이벤트에 대한 질문에 답변할 때 유용합니다. - 사용자가 LLM/RAG 에서도 없는 최신 정보가 불만족스럽거나, 그럴때 사용하는것.\n주요 매개변수 - max_results (int): 반환할 최대 검색 결과 수 (기본값: 5) - search_depth (str): 검색 깊이 (“basic” 또는 “advanced”) - include_domains (List[str]): 검색 결과에 포함할 도메인 목록 - exclude_domains (List[str]): 검색 결과에서 제외할 도메인 목록 - include_answer (bool): 원본 쿼리에 대한 짧은 답변 포함 여부 - include_raw_content (bool): 각 사이트의 정제된 HTML 콘텐츠 포함 여부 - include_images (bool): 쿼리 관련 이미지 목록 포함 여부\n반환 값 - 검색 결과를 포함하는 JSON 형식의 문자열(url, content)\n혹은 아래의 주석을 해제하고 발급받은 API 키를 입력합니다.\n\n\n코드\n# import os\n\n# os.environ[\"TAVILY_API_KEY\"] = \"TAVILY API 키 입력\"\n\n\n\n\n코드\nfrom langchain_community.tools.tavily_search import TavilySearchResults\n\n# 도구 생성\ntool = TavilySearchResults(\n    max_results=6,\n    include_answer=True,\n    include_raw_content=True,\n    # include_images=True,\n    # search_depth=\"advanced\", # or \"basic\"\n    include_domains=[\"github.io\", \"wikidocs.net\"],\n    # exclude_domains = []\n)\n\n\n\n\n코드\n# 도구 실행\ntool.invoke({\"query\": \"LangChain Tools 에 대해서 알려주세요\"})\n\n\n\n\n1.4 Image 생성 도구 (DALL-E)\n\nDallEAPIWrapper 클래스: OpenAI의 DALL-E 이미지 생성기를 위한 래퍼(wrapper)입니다.\n\n이 도구를 사용하면 DALL-E API를 쉽게 통합하여 텍스트 기반 이미지 생성 기능을 구현할 수 있습니다. 다양한 설정 옵션을 통해 유연하고 강력한 이미지 생성 도구로 활용할 수 있습니다.\n주요 속성\n\nmodel: 사용할 DALL-E 모델 이름 (기본값: “dall-e-2”, “dall-e-3”)\nn: 생성할 이미지 수 (기본값: 1)\nsize: 생성할 이미지 크기\n\n“dall-e-2”: “1024x1024”, “512x512”, “256x256”\n“dall-e-3”: “1024x1024”, “1792x1024”, “1024x1792”\n\nstyle: 생성될 이미지의 스타일 (기본값: “natural”, “vivid”)\nquality: 생성될 이미지의 품질 (기본값: “standard”, “hd”)\nmax_retries: 생성 시 최대 재시도 횟수\n\n주요 기능 - DALL-E API를 사용하여 텍스트 설명에 기반한 이미지 생성\n흐름 정리\n다음은 DALL-E Image Generator 를 사용하여 이미지를 생성하는 예제입니다.\n이번에는 DallEAPIWrapper 를 사용하여 이미지를 생성해 보겠습니다.\n이때 입력 프롬프트는 LLM 모델에게 이미지를 생성하는 프롬프트를 작성하도록 요청합니다.\n\n\n코드\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_core.prompts import PromptTemplate\nfrom langchain_openai import ChatOpenAI\n\n# ChatOpenAI 모델 초기화\nllm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0.9, max_tokens=1000)\n\n# DALL-E 이미지 생성을 위한 프롬프트 템플릿 정의\nprompt = PromptTemplate.from_template(\n    \"Generate a detailed IMAGE GENERATION prompt for DALL-E based on the following description. \"\n    \"Return only the prompt, no intro, no explanation, no chatty, no markdown, no code block, no nothing. Just the prompt\"\n    \"Output should be less than 1000 characters. Write in English only.\"\n    \"Image Description: \\n{image_desc}\",\n)\n\n# 프롬프트, LLM, 출력 파서를 연결하는 체인 생성\nchain = prompt | llm | StrOutputParser()\n\n# 체인 실행\nimage_prompt = chain.invoke(\n    {\"image_desc\": \"스마트폰을 바라보는 사람들을 풍자한 neo-classicism painting\"}\n)\n\n# 이미지 프롬프트 출력\nprint(image_prompt)\n\n\n그럼, 이전에 생성한 이미지 프롬프트를 DallEAPIWrapper 에 입력하여 이미지를 생성해 보겠습니다.\nDallEAPIWrapper 에 대한 임시 버그 안내사항 (작성일: 2024-10-13)\n\n현재 langchain 0.3.x 이상 버전에서 DallEAPIWrapper 에 대한 임시 버그가 있습니다. (401 오류: invalid API key)\n\n따라서, 아래의 코드를 오류 없이 실행하기 위해서는 LangChain 버전을 0.2.16 으로 변경해야 합니다.\n아래의 주석을 해제하고 실행하면 LangChain 버전을 0.2.16 으로 변경됩니다.\n하지만, 이후 내용에서는 LangChain 버전을 0.3.x 이상으로 변경하여 사용하기 때문에\npoetry shell 명령어를 통해 다시 최신 langchain 버전으로 변경해야 합니다.\n이 과정이 번거로운 분들은 일단 DallEAPIWrapper 를 사용하지 않고 진행하셔도 무방합니다.\n업그레이드/다운그레이드 후에는 반드시 상단 메뉴의 “Restart” 버튼을 클릭한 뒤 진행해야 합니다.\n\n\n코드\n# 임시 버전 다운그레이드 명령어 (실행 후 restart)\n# !pip install langchain==0.2.16 langchain-community==0.2.16 langchain-text-splitters==0.2.4 langchain-experimental==0.0.65 langchain-openai==0.1.20\n\n\n\n\n코드\n# DALL-E API 래퍼 가져오기\nfrom langchain_community.utilities.dalle_image_generator import DallEAPIWrapper\nfrom IPython.display import Image\nimport os\n\n# DALL-E API 래퍼 초기화\n# model: 사용할 DALL-E 모델 버전\n# size: 생성할 이미지 크기\n# quality: 이미지 품질\n# n: 생성할 이미지 수\ndalle = DallEAPIWrapper(\n    model=\"dall-e-3\",\n    size=\"1024x1024\",\n    quality=\"standard\",\n    n=1,\n)\n\n# 질문\nquery = \"스마트폰을 바라보는 사람들을 풍자한 neo-classicism painting\"\n\n# 이미지 생성 및 URL 받기\n# chain.invoke()를 사용하여 이미지 설명을 DALL-E 프롬프트로 변환\n# dalle.run()을 사용하여 실제 이미지 생성\nimage_url = dalle.run(chain.invoke({\"image_desc\": query}))\n\n# 생성된 이미지를 표시합니다.\nImage(url=image_url, width=500)"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/01-Tools.html#사용자-정의-도구custom-tool",
    "href": "docs/blog/posts/RAG/15-Agent/01-Tools.html#사용자-정의-도구custom-tool",
    "title": "도구 (Tools)",
    "section": "2 사용자 정의 도구(Custom Tool)",
    "text": "2 사용자 정의 도구(Custom Tool)\nLangChain 에서 제공하는 빌트인 도구 외에도 사용자가 직접 도구를 정의하여 사용할 수 있습니다.\n이를 위해서는 langchain.tools 모듈에서 제공하는 tool 데코레이터를 사용하여 함수를 도구로 변환합니다.\n\n2.1 @tool 데코레이터\n이 데코레이터는 함수를 도구로 변환하는 기능을 제공합니다. 다양한 옵션을 통해 도구의 동작을 커스터마이즈할 수 있습니다.\n사용 방법 1. 함수 위에 @tool 데코레이터 적용 2. 필요에 따라 데코레이터 매개변수 설정\n이 데코레이터를 사용하면 일반 Python 함수를 강력한 도구로 쉽게 변환할 수 있으며, 자동화된 문서화와 유연한 인터페이스 생성이 가능합니다.\n\n\n코드\nfrom langchain.tools import tool\n\n\n# 데코레이터를 사용하여 함수를 도구로 변환합니다.\n@tool\ndef add_numbers(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\n\n@tool\ndef multiply_numbers(a: int, b: int) -&gt; int:\n    \"\"\"Multiply two numbers\"\"\"\n    return a * b\n\n\n\n\n코드\n# 도구 실행\nadd_numbers.invoke({\"a\": 3, \"b\": 4})\n\n\n\n\n코드\n# 도구 실행\nmultiply_numbers.invoke({\"a\": 3, \"b\": 4})\n\n\n\n\n2.2 구글 뉴스기사 검색 도구\nlangchain-teddynote 패키지에서 제공하는 GoogleNews 도구를 사용하여 구글 뉴스기사를 검색하는 도구입니다.\n참고 - API 키가 필요하지 않습니다. (RSS 피드를 사용하기 때문)\nnews.google.com 에서 제공하는 뉴스기사를 검색하는 도구입니다.\n설명 - 구글 뉴스 검색 API를 사용하여 최신 뉴스를 검색합니다. - 키워드를 기반으로 뉴스를 검색할 수 있습니다. - 최신 뉴스를 검색할 수 있습니다.\n주요 매개변수 - k (int): 반환할 최대 검색 결과 수 (기본값: 5)\n사용하기 전 패키지를 업데이트 해주세요.\n\n\n코드\n# !pip install -qU langchain-teddynote\n\n\n\n\n코드\nfrom langchain_teddynote.tools import GoogleNews\n\n# 도구 생성\nnews_tool = GoogleNews()\n\n\n\n\n코드\n# 최신 뉴스 검색\nnews_tool.search_latest(k=5)\n\n\n\n\n코드\n# 키워드로 뉴스 검색\nnews_tool.search_by_keyword(\"AI 투자\", k=3)\n\n\n\n\n코드\nfrom langchain_teddynote.tools import GoogleNews\nfrom langchain.tools import tool\nfrom typing import List, Dict\n\n\n# 키워드로 뉴스 검색하는 도구 생성\n@tool\ndef search_keyword(query: str) -&gt; List[Dict[str, str]]:\n    \"\"\"Look up news by keyword\"\"\"\n    print(query)\n    news_tool = GoogleNews()\n    return news_tool.search_by_keyword(query, k=5)\n\n\n\n\n코드\n# 실행 결과\nsearch_keyword.invoke({\"query\": \"LangChain AI\"})"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html",
    "href": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html",
    "title": "LLM 에 도구 바인딩(Binding Tools)",
    "section": "",
    "text": "LLM 모델이 도구(tool) 를 호출할 수 있으려면 chat 요청을 할 때 모델에 도구 스키마(tool schema) 를 전달해야 합니다.\n도구 호출(tool calling) 기능을 지원하는 LangChain Chat Model 은 .bind_tools() 메서드를 구현하여 LangChain 도구 객체, Pydantic 클래스 또는 JSON 스키마 목록을 수신하고 공급자별 예상 형식으로 채팅 모델에 바인딩(binding) 합니다.\n바인딩된 Chat Model 의 후속 호출은 모델 API에 대한 모든 호출에 도구 스키마를 포함합니다.\n코드\n# API KEY를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API KEY 정보로드\nload_dotenv()\n코드\n# LangSmith 추적을 설정합니다. https://smith.langchain.com\n# !pip install -qU langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력합니다.\nlogging.langsmith(\"CH15-Bind-Tools\")"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html#llm에-바인딩할-tool-정의",
    "href": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html#llm에-바인딩할-tool-정의",
    "title": "LLM 에 도구 바인딩(Binding Tools)",
    "section": "1 LLM에 바인딩할 Tool 정의",
    "text": "1 LLM에 바인딩할 Tool 정의\n실험을 위한 도구(tool) 를 정의합니다.\n\nget_word_length : 단어의 길이를 반환하는 함수\nadd_function : 두 숫자를 더하는 함수\nnaver_news_crawl : 네이버 뉴스 기사를 크롤링하여 본문 내용을 반환하는 함수\n\n참고 - 도구를 정의할 때 @tool 데코레이터를 사용하여 도구를 정의합니다. - docstring 은 가급적 영어로 작성하는 것을 권장합니다.\n\n\n코드\nimport re\nimport requests\nfrom bs4 import BeautifulSoup\nfrom langchain.agents import tool\n\n\n# 도구를 정의합니다.\n@tool\ndef get_word_length(word: str) -&gt; int:\n    \"\"\"Returns the length of a word.\"\"\"\n    return len(word)\n\n\n@tool\ndef add_function(a: float, b: float) -&gt; float:\n    \"\"\"Adds two numbers together.\"\"\"\n    return a + b\n\n\n@tool\ndef naver_news_crawl(news_url: str) -&gt; str:\n    \"\"\"Crawls a 네이버 (naver.com) news article and returns the body content.\"\"\"\n    # HTTP GET 요청 보내기\n    response = requests.get(news_url)\n\n    # 요청이 성공했는지 확인\n    if response.status_code == 200:\n        # BeautifulSoup을 사용하여 HTML 파싱\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        # 원하는 정보 추출\n        title = soup.find(\"h2\", id=\"title_area\").get_text()\n        content = soup.find(\"div\", id=\"contents\").get_text()\n        cleaned_title = re.sub(r\"\\n{2,}\", \"\\n\", title)\n        cleaned_content = re.sub(r\"\\n{2,}\", \"\\n\", content)\n    else:\n        print(f\"HTTP 요청 실패. 응답 코드: {response.status_code}\")\n\n    return f\"{cleaned_title}\\n{cleaned_content}\"\n\n\ntools = [get_word_length, add_function, naver_news_crawl]"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html#bind_tools-로-llm-에-도구-바인딩",
    "href": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html#bind_tools-로-llm-에-도구-바인딩",
    "title": "LLM 에 도구 바인딩(Binding Tools)",
    "section": "2 bind_tools() 로 LLM 에 도구 바인딩",
    "text": "2 bind_tools() 로 LLM 에 도구 바인딩\nllm 모델에 bind_tools() 를 사용하여 도구를 바인딩합니다.\n\n\n코드\nfrom langchain_openai import ChatOpenAI\n\n# 모델 생성\nllm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)\n\n# 도구 바인딩\nllm_with_tools = llm.bind_tools(tools)\n\n\n실행결과를 확인합니다.\n결과는 tool_calls 에 저장됩니다. 따라서, .tool_calls 를 확인하여 도구 호출 결과를 확인할 수 있습니다.\n참고 - name 은 도구의 이름을 의미합니다. - args 는 도구에 전달되는 인자를 의미합니다.\n\n\n코드\n# 실행 결과\nllm_with_tools.invoke(\"What is the length of the word 'teddynote'?\").tool_calls\n\n\n다음으로는 llm_with_tools 와 JsonOutputToolsParser 를 연결하여 tool_calls 를 parsing 하여 결과를 확인합니다.\n\n\n코드\nfrom langchain_core.output_parsers.openai_tools import JsonOutputToolsParser\n\n# 도구 바인딩 + 도구 파서\nchain = llm_with_tools | JsonOutputToolsParser(tools=tools)\n\n# 실행 결과\ntool_call_results = chain.invoke(\"What is the length of the word 'teddynote'?\")\n\n\n\n\n코드\nprint(tool_call_results)\n\n\n실행 결과는 다음과 같습니다.\n참고 - type: 도구의 이름 - args: 도구에 전달되는 인자\n\n\n코드\nprint(tool_call_results, end=\"\\n\\n==========\\n\\n\")\n# 첫 번째 도구 호출 결과\nsingle_result = tool_call_results[0]\n# 도구 이름\nprint(single_result[\"type\"])\n# 도구 인자\nprint(single_result[\"args\"])\n\n\n도구 이름과 일치하는 도구를 찾아 실행합니다.\n\n\n코드\ntool_call_results[0][\"type\"], tools[0].name\n\n\nexecute_tool_calls 함수는 도구를 찾아 args 를 전달하여 도구를 실행합니다.\n즉, type 은 도구의 이름을 의미하고 args 는 도구에 전달되는 인자를 의미합니다.\n\n\n코드\ndef execute_tool_calls(tool_call_results):\n    \"\"\"\n    도구 호출 결과를 실행하는 함수\n\n    :param tool_call_results: 도구 호출 결과 리스트\n    :param tools: 사용 가능한 도구 리스트\n    \"\"\"\n    # 도구 호출 결과 리스트를 순회합니다.\n    for tool_call_result in tool_call_results:\n        # 도구의 이름과 인자를 추출합니다.\n        tool_name = tool_call_result[\"type\"]  # 도구의 이름(함수명)\n        tool_args = tool_call_result[\"args\"]  # 도구에 전달되는 인자\n\n        # 도구 이름과 일치하는 도구를 찾아 실행합니다.\n        # next() 함수를 사용하여 일치하는 첫 번째 도구를 찾습니다.\n        matching_tool = next((tool for tool in tools if tool.name == tool_name), None)\n\n        if matching_tool:\n            # 일치하는 도구를 찾았다면 해당 도구를 실행합니다.\n            result = matching_tool.invoke(tool_args)\n            # 실행 결과를 출력합니다.\n            print(f\"[실행도구] {tool_name} [Argument] {tool_args}\\n[실행결과] {result}\")\n        else:\n            # 일치하는 도구를 찾지 못했다면 경고 메시지를 출력합니다.\n            print(f\"경고: {tool_name}에 해당하는 도구를 찾을 수 없습니다.\")\n\n\n# 도구 호출 실행\n# 이전에 얻은 tool_call_results를 인자로 전달하여 함수를 실행합니다.\nexecute_tool_calls(tool_call_results)"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html#bind_tools-parser-execution",
    "href": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html#bind_tools-parser-execution",
    "title": "LLM 에 도구 바인딩(Binding Tools)",
    "section": "3 bind_tools + Parser + Execution",
    "text": "3 bind_tools + Parser + Execution\n이번에는 일련의 과정을 한 번에 실행합니다.\n\nllm_with_tools : 도구를 바인딩한 모델\nJsonOutputToolsParser : 도구 호출 결과를 파싱하는 파서\nexecute_tool_calls : 도구 호출 결과를 실행하는 함수\n\n흐름 정리 1. 모델에 도구를 바인딩 2. 도구 호출 결과를 파싱 3. 도구 호출 결과를 실행\n\n\n코드\nfrom langchain_core.output_parsers.openai_tools import JsonOutputToolsParser\n\n# bind_tools + Parser + Execution\nchain = llm_with_tools | JsonOutputToolsParser(tools=tools) | execute_tool_calls\n\n\n\n\n코드\n# 실행 결과\nchain.invoke(\"What is the length of the word 'teddynote'?\")\n\n\n\n\n코드\n# 실행 결과\nchain.invoke(\"114.5 + 121.2\")\nprint(114.5 + 121.2)\n\n\n\n\n코드\n# 실행 결과\nchain.invoke(\n    \"뉴스 기사 내용을 크롤링해줘: https://n.news.naver.com/mnews/hotissue/article/092/0002347672?type=series&cid=2000065\"\n)"
  },
  {
    "objectID": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html#bind_tools-agent-agentexecutor-로-대체",
    "href": "docs/blog/posts/RAG/15-Agent/02-Bind-Tools.html#bind_tools-agent-agentexecutor-로-대체",
    "title": "LLM 에 도구 바인딩(Binding Tools)",
    "section": "4 bind_tools > Agent & AgentExecutor 로 대체",
    "text": "4 bind_tools &gt; Agent & AgentExecutor 로 대체\nbind_tools() 는 모델에 사용할 수 있는 스키마(도구)를 제공합니다.\nAgentExecutor 는 실제로 llm 호출, 올바른 도구로 라우팅, 실행, 모델 재호출 등을 위한 실행 루프를 생성합니다.\n참고 - Agent 와 AgentExecutor 에 대해서는 다음 장에서 자세히 다룹니다.\n\n\n코드\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder\nfrom langchain_openai import ChatOpenAI\n\n# Agent 프롬프트 생성\nprompt = ChatPromptTemplate.from_messages(\n    [\n        (\n            \"system\",\n            \"You are very powerful assistant, but don't know current events\",\n        ),\n        (\"user\", \"{input}\"),\n        MessagesPlaceholder(variable_name=\"agent_scratchpad\"),\n    ]\n)\n\n# 모델 생성\nllm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)\n\n\n\n\n코드\nfrom langchain.agents import create_tool_calling_agent\nfrom langchain.agents import AgentExecutor\n\n# 이전에 정의한 도구 사용\ntools = [get_word_length, add_function, naver_news_crawl]\n\n# Agent 생성\nagent = create_tool_calling_agent(llm, tools, prompt)\n\n# AgentExecutor 생성\nagent_executor = AgentExecutor(\n    agent=agent,\n    tools=tools,\n    verbose=True,\n    handle_parsing_errors=True,\n)\n\n\n\n\n코드\n# Agent 실행\nresult = agent_executor.invoke({\"input\": \"How many letters in the word `teddynote`?\"})\n\n# 결과 확인\nprint(result[\"output\"])\n\n\n\n\n코드\n# Agent 실행\nresult = agent_executor.invoke({\"input\": \"114.5 + 121.2 의 계산 결과는?\"})\n\n# 결과 확인\nprint(result[\"output\"])\n\n\n한 번의 실행으로 끝나는 것이 아닌, 모델이 자신의 결과를 확인하고 다시 자신을 호출하는 과정을 거칩니다.\n\n\n코드\n# Agent 실행\nresult = agent_executor.invoke(\n    {\"input\": \"114.5 + 121.2 + 34.2 + 110.1 의 계산 결과는?\"}\n)\n\n# 결과 확인\nprint(result[\"output\"])\nprint(\"==========\\n\")\nprint(114.5 + 121.2 + 34.2 + 110.1)\n\n\n이번에는 뉴스 결과를 크롤링 해서 요약 해달라는 요청을 수행합니다.\n\n\n코드\nresult = agent_executor.invoke(\n    {\n        \"input\": \"뉴스 기사를 요약해 줘: https://n.news.naver.com/mnews/hotissue/article/092/0002347672?type=series&cid=2000065\"\n    }\n)\nprint(result[\"output\"])"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화\n\n\n\n\n\nPromptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장\n\n\n\n\n\n\n\n\n\n\n\n\n항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#프롬프트의-정의",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#프롬프트의-정의",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "Promptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#개념",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#개념",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.1 2.1 개념",
    "text": "2.1 2.1 개념\n\n방대한 데이터 기반 사전학습 모델\nAutoregression: 이전 토큰 기반으로 다음 단어 예측\n기반 기술: Transformer 구조(셀프 어텐션)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#주요-모델-패밀리",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#주요-모델-패밀리",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.2 2.2 주요 모델 패밀리",
    "text": "2.2 2.2 주요 모델 패밀리\n\nOpenAI – GPT-4o: 멀티모달·실시간 처리\nAnthropic – Claude 3: 안전성 중점, 헌법적 AI\nGoogle – Gemini / BERT / T5: 다중 모달 처리"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#모델-튜닝-방식",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#모델-튜닝-방식",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.3 2.3 모델 튜닝 방식",
    "text": "2.3 2.3 모델 튜닝 방식\n\nFine-Tuning\nPrompt Engineering\nFeature-Tuning(특징 공간 해석 기반 제어)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#필수-4요소",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#필수-4요소",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.1 3.1 필수 4요소",
    "text": "3.1 3.1 필수 4요소\n\nInstruction: 어떤 작업을 해야 하는가\nContext: 배경 정보\nInput Data: 처리 대상 데이터\nOutput Indicator: 출력 형식 규정"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.2 3.2 프롬프트 타입 구조(Type A–D)",
    "text": "3.2 3.2 프롬프트 타입 구조(Type A–D)\n\nA: 지시문 + 출력문\nB: 지시문 + 맥락 + 출력문\nC: 지시문 + 맥락 + 예시 + 출력문\nD: 지시문 + 입력값 + 출력문\n\n예시와 함께 구조적으로 프롬프트를 설계하면 LLM이 더 안정적으로 원하는 출력 생성."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#대-원칙",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#대-원칙",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.1 4.1 4대 원칙",
    "text": "4.1 4.1 4대 원칙\n\n범용성: 다양한 상황에서도 동작\n목적 지향성: 특정 사용자 목적 반영\n일관성: 반복 실행해도 동일 품질\n경제성: API 비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#scaffolding-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#scaffolding-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.2 4.2 Scaffolding Prompting",
    "text": "4.2 4.2 Scaffolding Prompting\n\n인간의 학습 이론(ZPD)을 적용\nUnderstand → Ideation → Analysis → Apply → Evaluate → Generalize\n단계적 사고구조 유도"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#핵심-5-tips",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#핵심-5-tips",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.3 4.3 핵심 5 Tips",
    "text": "4.3 4.3 핵심 5 Tips\n\n4.3.1 Tip1. 최신 모델 사용\n\n\n4.3.2 Tip2. 명확한 동사로 지시\n예: 분석해, 정리해, 요약해, 작성해 등\n\n\n4.3.3 Tip 3. 프롬프트를 구조화하자\n프롬프트를 구조화하면 LLM이 입력을 더 명확하게 해석할 수 있고,\n작업 목적·규칙·입력 데이터·출력 형식을 혼동 없이 처리할 수 있다.\n구조화를 위한 핵심 기법은 Markdown, 코드 프롬프트, XML 태그이다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)",
    "text": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)\nMarkdown은 LLM이 가장 잘 해석하는 구조적 문법 중 하나이다.\n섹션을 명확히 나누고, 각 부분을 시각적으로 구분해줌으로써\n모델의 오류를 줄이고 반복 작업 시 유지보수성이 높아진다.\n\n4.4.1 1) 헤더(Headers) 활용\n헤더는 프롬프트의 구성을 크게 나누는 데 사용한다.\n# 역할(Role)\n너는 스포츠 기사 분석 엔진이다.\n\n## 작업(Task)\n아래 텍스트에서 장소(도시, 국가, 축구 클럽)를 모두 추출해라.\n\n## 출력 형식(Format)\n- \"장소: A, B, C\" 형태의 한 줄 출력\n- 설명 금지\n\n## 텍스트(Text)\n{{TEXT}}\n\n\n4.4.2 2) 목록(Lists) 활용\n절차, 규칙, 조건을 번호 목록으로 정리하면 LLM이 하나씩 적용하기 쉽다.\n다음 규칙을 따라 작업을 수행해라.\n1. 사람 이름은 제외한다.\n2. 축구 클럽은 장소로 포함한다.\n3. 결과는 쉼표로 구분한다.\n4. 설명 문장은 쓰지 않는다.\n\n\n4.4.3 3) 강조(Emphasis) 사용\n중요 조건을 굵게 또는 기울임으로 표시해 모델의 우선순위를 높인다.\n- 반드시 **한국어**로 작성하라.\n- 출력은 **한 줄**로만 작성한다.\n- *설명 문장은 포함하지 않는다.*"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.5 3.2 코드 프롬프트(Code Prompting)",
    "text": "4.5 3.2 코드 프롬프트(Code Prompting)\n자연어 대신 코드 형식으로 의도를 명세하면 애매함이 줄어들고 LLM이 구조적으로 이해해 할루시네이션이 감소한다.\n# 역할 정의\nrole = \"정보 추출 엔진\"\n\n# 작업 정의\ntask = \"텍스트에서 '장소명'을 추출해 정렬된 리스트로 반환\"\n\n# 출력 형식 정의\noutput = {\n    \"places\": [\"string\"]\n}\n코드 방식의 장점:\n\n논리 구조가 명확하게 표현됨\n조건과 출력 형식이 혼동되지 않음\n정형화된 포맷을 자주 재사용 가능"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)",
    "text": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)\nXML 태그는 텍스트 내 특정 영역을 명확히 구분해 Claude뿐 아니라 대부분의 LLM에서 구조적 파싱을 돕는 강력한 방식이다.\n\n4.6.1 1) 태그로 영역 지정\n&lt;email&gt;\nShow up at 6AM because I say so.\n&lt;/email&gt;\n\nMake this email more polite.\nLLM은 &lt;email&gt;...&lt;/email&gt; 내부 텍스트만 변환하면 된다는 것을 명확히 인식한다.\n\n\n4.6.2 2) 데이터 템플릿 예시\n&lt;animal&gt;{{ANIMAL}}&lt;/animal&gt;\n입력만 바꿔 여러 데이터를 동일한 템플릿에 적용할 수 있다.\n예:\n&lt;animal&gt;Cow&lt;/animal&gt;\n&lt;animal&gt;Dog&lt;/animal&gt;\n&lt;animal&gt;Seal&lt;/animal&gt;\n장점:\n\n구역별 의미가 명확\n반복 작업에서 수정이 쉽고 안정적\n모델이 태그 단위로 파싱하기 때문에 오류 감소"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.7 3.4 구조화 기법이 필요한 이유",
    "text": "4.7 3.4 구조화 기법이 필요한 이유\n\n명령어, 입력 데이터, 출력 형식을 명확히 구분해 모델의 해석 오류를 줄인다.\n규칙을 시각적으로 구분하여 작업 수행 품질의 일관성과 재현성을 높인다.\n재사용 가능한 템플릿이 되어 프롬프트 제작 비용과 시간 절감에 기여한다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.8 3.5 구조화 적용 사례 (장소명 추출)",
    "text": "4.8 3.5 구조화 적용 사례 (장소명 추출)\n# 역할(Role)\n너는 텍스트에서 장소명을 추출하는 엔진이다.\n\n## 작업(Task)\n텍스트 내 도시, 국가, 축구 클럽 이름을 모두 \"장소\"로 간주하고 추출해라.\n\n## 출력 형식(Format)\n- 한 줄로만 출력한다.\n- 형식: `장소: A, B, C`\n- 설명 문장 금지.\n\n## 텍스트(Text)\n음바페는 26일 쿠프 드 프랑스 프랑스컵 올랭피크 리옹과의\n결승전에서 풀타임을 뛰며 2-1로 팀 승리를 도왔다.\n3년 만에 대회 정상에 오른 PSG는 역대 최다 15회 우승으로\n2위 마르세유(10회)를 멀찍이 따돌렸다.\n음바페는 이날 PSG에서의 커리어를 마무리했다.\n\n4.8.1 Tip4. 단문 중심\n\n한국어는 짧고 명확하게 작성\n톤·형식·분량을 구체적으로 지시\n\n\n\n4.8.2 Tip5. 하지 말 것(X) → 할 것(O)\n\n부정 지시보다 긍정적 행동 지시가 안정적"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#llm-한계",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#llm-한계",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.1 5.1 LLM 한계",
    "text": "5.1 5.1 LLM 한계\n\n할루시네이션\n편향성\n근거 없는 출처 생성\n수학 및 추론 한계\nPrompt Injection(프롬프트 해킹)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유",
    "text": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유\n\n정확성 향상\n오류 및 편향 감소\n모델 행동 제어\n사용자 경험 개선\n비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화\n\n\n\n\n\nPromptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장\n\n\n\n\n\n\n\n\n\n\n\n\n항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#프롬프트의-정의",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#프롬프트의-정의",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "Promptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#개념",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#개념",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.1 2.1 개념",
    "text": "2.1 2.1 개념\n\n방대한 데이터 기반 사전학습 모델\nAutoregression: 이전 토큰 기반으로 다음 단어 예측\n기반 기술: Transformer 구조(셀프 어텐션)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#주요-모델-패밀리",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#주요-모델-패밀리",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.2 2.2 주요 모델 패밀리",
    "text": "2.2 2.2 주요 모델 패밀리\n\nOpenAI – GPT-4o: 멀티모달·실시간 처리\nAnthropic – Claude 3: 안전성 중점, 헌법적 AI\nGoogle – Gemini / BERT / T5: 다중 모달 처리"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#모델-튜닝-방식",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#모델-튜닝-방식",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.3 2.3 모델 튜닝 방식",
    "text": "2.3 2.3 모델 튜닝 방식\n\nFine-Tuning\nPrompt Engineering\nFeature-Tuning(특징 공간 해석 기반 제어)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#필수-4요소",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#필수-4요소",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.1 3.1 필수 4요소",
    "text": "3.1 3.1 필수 4요소\n\nInstruction: 어떤 작업을 해야 하는가\nContext: 배경 정보\nInput Data: 처리 대상 데이터\nOutput Indicator: 출력 형식 규정"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.2 3.2 프롬프트 타입 구조(Type A–D)",
    "text": "3.2 3.2 프롬프트 타입 구조(Type A–D)\n\nA: 지시문 + 출력문\nB: 지시문 + 맥락 + 출력문\nC: 지시문 + 맥락 + 예시 + 출력문\nD: 지시문 + 입력값 + 출력문\n\n예시와 함께 구조적으로 프롬프트를 설계하면 LLM이 더 안정적으로 원하는 출력 생성."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#대-원칙",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#대-원칙",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.1 4.1 4대 원칙",
    "text": "4.1 4.1 4대 원칙\n\n범용성: 다양한 상황에서도 동작\n목적 지향성: 특정 사용자 목적 반영\n일관성: 반복 실행해도 동일 품질\n경제성: API 비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#scaffolding-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#scaffolding-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.2 4.2 Scaffolding Prompting",
    "text": "4.2 4.2 Scaffolding Prompting\n\n인간의 학습 이론(ZPD)을 적용\nUnderstand → Ideation → Analysis → Apply → Evaluate → Generalize\n단계적 사고구조 유도"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#핵심-5-tips",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#핵심-5-tips",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.3 4.3 핵심 5 Tips",
    "text": "4.3 4.3 핵심 5 Tips\n\n4.3.1 Tip1. 최신 모델 사용\n\n\n4.3.2 Tip2. 명확한 동사로 지시\n예: 분석해, 정리해, 요약해, 작성해 등\n\n\n4.3.3 Tip 3. 프롬프트를 구조화하자\n프롬프트를 구조화하면 LLM이 입력을 더 명확하게 해석할 수 있고,\n작업 목적·규칙·입력 데이터·출력 형식을 혼동 없이 처리할 수 있다.\n구조화를 위한 핵심 기법은 Markdown, 코드 프롬프트, XML 태그이다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)",
    "text": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)\nMarkdown은 LLM이 가장 잘 해석하는 구조적 문법 중 하나이다.\n섹션을 명확히 나누고, 각 부분을 시각적으로 구분해줌으로써\n모델의 오류를 줄이고 반복 작업 시 유지보수성이 높아진다.\n\n4.4.1 1) 헤더(Headers) 활용\n헤더는 프롬프트의 구성을 크게 나누는 데 사용한다.\n# 역할(Role)\n너는 스포츠 기사 분석 엔진이다.\n\n## 작업(Task)\n아래 텍스트에서 장소(도시, 국가, 축구 클럽)를 모두 추출해라.\n\n## 출력 형식(Format)\n- \"장소: A, B, C\" 형태의 한 줄 출력\n- 설명 금지\n\n## 텍스트(Text)\n{{TEXT}}\n\n\n4.4.2 2) 목록(Lists) 활용\n절차, 규칙, 조건을 번호 목록으로 정리하면 LLM이 하나씩 적용하기 쉽다.\n다음 규칙을 따라 작업을 수행해라.\n1. 사람 이름은 제외한다.\n2. 축구 클럽은 장소로 포함한다.\n3. 결과는 쉼표로 구분한다.\n4. 설명 문장은 쓰지 않는다.\n\n\n4.4.3 3) 강조(Emphasis) 사용\n중요 조건을 굵게 또는 기울임으로 표시해 모델의 우선순위를 높인다.\n- 반드시 **한국어**로 작성하라.\n- 출력은 **한 줄**로만 작성한다.\n- *설명 문장은 포함하지 않는다.*"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.5 3.2 코드 프롬프트(Code Prompting)",
    "text": "4.5 3.2 코드 프롬프트(Code Prompting)\n자연어 대신 코드 형식으로 의도를 명세하면 애매함이 줄어들고 LLM이 구조적으로 이해해 할루시네이션이 감소한다.\n# 역할 정의\nrole = \"정보 추출 엔진\"\n\n# 작업 정의\ntask = \"텍스트에서 '장소명'을 추출해 정렬된 리스트로 반환\"\n\n# 출력 형식 정의\noutput = {\n    \"places\": [\"string\"]\n}\n코드 방식의 장점:\n\n논리 구조가 명확하게 표현됨\n조건과 출력 형식이 혼동되지 않음\n정형화된 포맷을 자주 재사용 가능"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)",
    "text": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)\nXML 태그는 텍스트 내 특정 영역을 명확히 구분해 Claude뿐 아니라 대부분의 LLM에서 구조적 파싱을 돕는 강력한 방식이다.\n\n4.6.1 1) 태그로 영역 지정\n&lt;email&gt;\nShow up at 6AM because I say so.\n&lt;/email&gt;\n\nMake this email more polite.\nLLM은 &lt;email&gt;...&lt;/email&gt; 내부 텍스트만 변환하면 된다는 것을 명확히 인식한다.\n\n\n4.6.2 2) 데이터 템플릿 예시\n&lt;animal&gt;{{ANIMAL}}&lt;/animal&gt;\n입력만 바꿔 여러 데이터를 동일한 템플릿에 적용할 수 있다.\n예:\n&lt;animal&gt;Cow&lt;/animal&gt;\n&lt;animal&gt;Dog&lt;/animal&gt;\n&lt;animal&gt;Seal&lt;/animal&gt;\n장점:\n\n구역별 의미가 명확\n반복 작업에서 수정이 쉽고 안정적\n모델이 태그 단위로 파싱하기 때문에 오류 감소"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.7 3.4 구조화 기법이 필요한 이유",
    "text": "4.7 3.4 구조화 기법이 필요한 이유\n\n명령어, 입력 데이터, 출력 형식을 명확히 구분해 모델의 해석 오류를 줄인다.\n규칙을 시각적으로 구분하여 작업 수행 품질의 일관성과 재현성을 높인다.\n재사용 가능한 템플릿이 되어 프롬프트 제작 비용과 시간 절감에 기여한다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.8 3.5 구조화 적용 사례 (장소명 추출)",
    "text": "4.8 3.5 구조화 적용 사례 (장소명 추출)\n# 역할(Role)\n너는 텍스트에서 장소명을 추출하는 엔진이다.\n\n## 작업(Task)\n텍스트 내 도시, 국가, 축구 클럽 이름을 모두 \"장소\"로 간주하고 추출해라.\n\n## 출력 형식(Format)\n- 한 줄로만 출력한다.\n- 형식: `장소: A, B, C`\n- 설명 문장 금지.\n\n## 텍스트(Text)\n음바페는 26일 쿠프 드 프랑스 프랑스컵 올랭피크 리옹과의\n결승전에서 풀타임을 뛰며 2-1로 팀 승리를 도왔다.\n3년 만에 대회 정상에 오른 PSG는 역대 최다 15회 우승으로\n2위 마르세유(10회)를 멀찍이 따돌렸다.\n음바페는 이날 PSG에서의 커리어를 마무리했다.\n\n4.8.1 Tip4. 단문 중심\n\n한국어는 짧고 명확하게 작성\n톤·형식·분량을 구체적으로 지시\n\n\n\n4.8.2 Tip5. 하지 말 것(X) → 할 것(O)\n\n부정 지시보다 긍정적 행동 지시가 안정적"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#llm-한계",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#llm-한계",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.1 5.1 LLM 한계",
    "text": "5.1 5.1 LLM 한계\n\n할루시네이션\n편향성\n근거 없는 출처 생성\n수학 및 추론 한계\nPrompt Injection(프롬프트 해킹)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 4/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유",
    "text": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유\n\n정확성 향상\n오류 및 편향 감소\n모델 행동 제어\n사용자 경험 개선\n비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화\n\n\n\n\n\nPromptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장\n\n\n\n\n\n\n\n\n\n\n\n\n항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#프롬프트의-정의",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#프롬프트의-정의",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "Promptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#개념",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#개념",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.1 2.1 개념",
    "text": "2.1 2.1 개념\n\n방대한 데이터 기반 사전학습 모델\nAutoregression: 이전 토큰 기반으로 다음 단어 예측\n기반 기술: Transformer 구조(셀프 어텐션)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#주요-모델-패밀리",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#주요-모델-패밀리",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.2 2.2 주요 모델 패밀리",
    "text": "2.2 2.2 주요 모델 패밀리\n\nOpenAI – GPT-4o: 멀티모달·실시간 처리\nAnthropic – Claude 3: 안전성 중점, 헌법적 AI\nGoogle – Gemini / BERT / T5: 다중 모달 처리"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#모델-튜닝-방식",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#모델-튜닝-방식",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.3 2.3 모델 튜닝 방식",
    "text": "2.3 2.3 모델 튜닝 방식\n\nFine-Tuning\nPrompt Engineering\nFeature-Tuning(특징 공간 해석 기반 제어)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#필수-4요소",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#필수-4요소",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.1 3.1 필수 4요소",
    "text": "3.1 3.1 필수 4요소\n\nInstruction: 어떤 작업을 해야 하는가\nContext: 배경 정보\nInput Data: 처리 대상 데이터\nOutput Indicator: 출력 형식 규정"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.2 3.2 프롬프트 타입 구조(Type A–D)",
    "text": "3.2 3.2 프롬프트 타입 구조(Type A–D)\n\nA: 지시문 + 출력문\nB: 지시문 + 맥락 + 출력문\nC: 지시문 + 맥락 + 예시 + 출력문\nD: 지시문 + 입력값 + 출력문\n\n예시와 함께 구조적으로 프롬프트를 설계하면 LLM이 더 안정적으로 원하는 출력 생성."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#대-원칙",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#대-원칙",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.1 4.1 4대 원칙",
    "text": "4.1 4.1 4대 원칙\n\n범용성: 다양한 상황에서도 동작\n목적 지향성: 특정 사용자 목적 반영\n일관성: 반복 실행해도 동일 품질\n경제성: API 비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#scaffolding-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#scaffolding-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.2 4.2 Scaffolding Prompting",
    "text": "4.2 4.2 Scaffolding Prompting\n\n인간의 학습 이론(ZPD)을 적용\nUnderstand → Ideation → Analysis → Apply → Evaluate → Generalize\n단계적 사고구조 유도"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#핵심-5-tips",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#핵심-5-tips",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.3 4.3 핵심 5 Tips",
    "text": "4.3 4.3 핵심 5 Tips\n\n4.3.1 Tip1. 최신 모델 사용\n\n\n4.3.2 Tip2. 명확한 동사로 지시\n예: 분석해, 정리해, 요약해, 작성해 등\n\n\n4.3.3 Tip 3. 프롬프트를 구조화하자\n프롬프트를 구조화하면 LLM이 입력을 더 명확하게 해석할 수 있고,\n작업 목적·규칙·입력 데이터·출력 형식을 혼동 없이 처리할 수 있다.\n구조화를 위한 핵심 기법은 Markdown, 코드 프롬프트, XML 태그이다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)",
    "text": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)\nMarkdown은 LLM이 가장 잘 해석하는 구조적 문법 중 하나이다.\n섹션을 명확히 나누고, 각 부분을 시각적으로 구분해줌으로써\n모델의 오류를 줄이고 반복 작업 시 유지보수성이 높아진다.\n\n4.4.1 1) 헤더(Headers) 활용\n헤더는 프롬프트의 구성을 크게 나누는 데 사용한다.\n# 역할(Role)\n너는 스포츠 기사 분석 엔진이다.\n\n## 작업(Task)\n아래 텍스트에서 장소(도시, 국가, 축구 클럽)를 모두 추출해라.\n\n## 출력 형식(Format)\n- \"장소: A, B, C\" 형태의 한 줄 출력\n- 설명 금지\n\n## 텍스트(Text)\n{{TEXT}}\n\n\n4.4.2 2) 목록(Lists) 활용\n절차, 규칙, 조건을 번호 목록으로 정리하면 LLM이 하나씩 적용하기 쉽다.\n다음 규칙을 따라 작업을 수행해라.\n1. 사람 이름은 제외한다.\n2. 축구 클럽은 장소로 포함한다.\n3. 결과는 쉼표로 구분한다.\n4. 설명 문장은 쓰지 않는다.\n\n\n4.4.3 3) 강조(Emphasis) 사용\n중요 조건을 굵게 또는 기울임으로 표시해 모델의 우선순위를 높인다.\n- 반드시 **한국어**로 작성하라.\n- 출력은 **한 줄**로만 작성한다.\n- *설명 문장은 포함하지 않는다.*"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.5 3.2 코드 프롬프트(Code Prompting)",
    "text": "4.5 3.2 코드 프롬프트(Code Prompting)\n자연어 대신 코드 형식으로 의도를 명세하면 애매함이 줄어들고 LLM이 구조적으로 이해해 할루시네이션이 감소한다.\n# 역할 정의\nrole = \"정보 추출 엔진\"\n\n# 작업 정의\ntask = \"텍스트에서 '장소명'을 추출해 정렬된 리스트로 반환\"\n\n# 출력 형식 정의\noutput = {\n    \"places\": [\"string\"]\n}\n코드 방식의 장점:\n\n논리 구조가 명확하게 표현됨\n조건과 출력 형식이 혼동되지 않음\n정형화된 포맷을 자주 재사용 가능"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)",
    "text": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)\nXML 태그는 텍스트 내 특정 영역을 명확히 구분해 Claude뿐 아니라 대부분의 LLM에서 구조적 파싱을 돕는 강력한 방식이다.\n\n4.6.1 1) 태그로 영역 지정\n&lt;email&gt;\nShow up at 6AM because I say so.\n&lt;/email&gt;\n\nMake this email more polite.\nLLM은 &lt;email&gt;...&lt;/email&gt; 내부 텍스트만 변환하면 된다는 것을 명확히 인식한다.\n\n\n4.6.2 2) 데이터 템플릿 예시\n&lt;animal&gt;{{ANIMAL}}&lt;/animal&gt;\n입력만 바꿔 여러 데이터를 동일한 템플릿에 적용할 수 있다.\n예:\n&lt;animal&gt;Cow&lt;/animal&gt;\n&lt;animal&gt;Dog&lt;/animal&gt;\n&lt;animal&gt;Seal&lt;/animal&gt;\n장점:\n\n구역별 의미가 명확\n반복 작업에서 수정이 쉽고 안정적\n모델이 태그 단위로 파싱하기 때문에 오류 감소"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.7 3.4 구조화 기법이 필요한 이유",
    "text": "4.7 3.4 구조화 기법이 필요한 이유\n\n명령어, 입력 데이터, 출력 형식을 명확히 구분해 모델의 해석 오류를 줄인다.\n규칙을 시각적으로 구분하여 작업 수행 품질의 일관성과 재현성을 높인다.\n재사용 가능한 템플릿이 되어 프롬프트 제작 비용과 시간 절감에 기여한다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.8 3.5 구조화 적용 사례 (장소명 추출)",
    "text": "4.8 3.5 구조화 적용 사례 (장소명 추출)\n# 역할(Role)\n너는 텍스트에서 장소명을 추출하는 엔진이다.\n\n## 작업(Task)\n텍스트 내 도시, 국가, 축구 클럽 이름을 모두 \"장소\"로 간주하고 추출해라.\n\n## 출력 형식(Format)\n- 한 줄로만 출력한다.\n- 형식: `장소: A, B, C`\n- 설명 문장 금지.\n\n## 텍스트(Text)\n음바페는 26일 쿠프 드 프랑스 프랑스컵 올랭피크 리옹과의\n결승전에서 풀타임을 뛰며 2-1로 팀 승리를 도왔다.\n3년 만에 대회 정상에 오른 PSG는 역대 최다 15회 우승으로\n2위 마르세유(10회)를 멀찍이 따돌렸다.\n음바페는 이날 PSG에서의 커리어를 마무리했다.\n\n4.8.1 Tip4. 단문 중심\n\n한국어는 짧고 명확하게 작성\n톤·형식·분량을 구체적으로 지시\n\n\n\n4.8.2 Tip5. 하지 말 것(X) → 할 것(O)\n\n부정 지시보다 긍정적 행동 지시가 안정적"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#llm-한계",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#llm-한계",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.1 5.1 LLM 한계",
    "text": "5.1 5.1 LLM 한계\n\n할루시네이션\n편향성\n근거 없는 출처 생성\n수학 및 추론 한계\nPrompt Injection(프롬프트 해킹)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy 2/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유",
    "text": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유\n\n정확성 향상\n오류 및 편향 감소\n모델 행동 제어\n사용자 경험 개선\n비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화\n\n\n\n\n\nPromptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장\n\n\n\n\n\n\n\n\n\n\n\n\n항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#인간-컴퓨터-상호작용의-변화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "문자의 발명 → 인류의 기록 정확도 향상\n인쇄술 → 지식 대중화\n전화·라디오·TV → 즉각적인 원격 소통\n인터넷·모바일 → 실시간 대화\n생성형 AI → 인간-기계 상호작용 고도화"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#프롬프트의-정의",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#프롬프트의-정의",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "Promptus(나타내다/생산하다)에서 유래\n현재 의미: 행동을 유도하는 신호\nAI에서: 모델에게 답변을 생성하도록 입력하는 문장"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#프롬프트-vs-프롬프트-엔지니어링",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "",
    "text": "항목\n프롬프트\n프롬프트 엔지니어링\n\n\n\n\n목적\n응답 생성 요청\n원하는 형태로 정확한 응답을 얻기 위한 설계\n\n\n필요성\n기본 입력\n모델 작동 방식·언어적 맥락 이해 필요\n\n\n예시\n“용에 대한 이야기 해줘”\n“용감한 용이 마을을 구하는 5문장 이야기 생성해줘. 대화 포함.”"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#개념",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#개념",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.1 2.1 개념",
    "text": "2.1 2.1 개념\n\n방대한 데이터 기반 사전학습 모델\nAutoregression: 이전 토큰 기반으로 다음 단어 예측\n기반 기술: Transformer 구조(셀프 어텐션)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#주요-모델-패밀리",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#주요-모델-패밀리",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.2 2.2 주요 모델 패밀리",
    "text": "2.2 2.2 주요 모델 패밀리\n\nOpenAI – GPT-4o: 멀티모달·실시간 처리\nAnthropic – Claude 3: 안전성 중점, 헌법적 AI\nGoogle – Gemini / BERT / T5: 다중 모달 처리"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#모델-튜닝-방식",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#모델-튜닝-방식",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "2.3 2.3 모델 튜닝 방식",
    "text": "2.3 2.3 모델 튜닝 방식\n\nFine-Tuning\nPrompt Engineering\nFeature-Tuning(특징 공간 해석 기반 제어)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#필수-4요소",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#필수-4요소",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.1 3.1 필수 4요소",
    "text": "3.1 3.1 필수 4요소\n\nInstruction: 어떤 작업을 해야 하는가\nContext: 배경 정보\nInput Data: 처리 대상 데이터\nOutput Indicator: 출력 형식 규정"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#프롬프트-타입-구조type-ad",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "3.2 3.2 프롬프트 타입 구조(Type A–D)",
    "text": "3.2 3.2 프롬프트 타입 구조(Type A–D)\n\nA: 지시문 + 출력문\nB: 지시문 + 맥락 + 출력문\nC: 지시문 + 맥락 + 예시 + 출력문\nD: 지시문 + 입력값 + 출력문\n\n예시와 함께 구조적으로 프롬프트를 설계하면 LLM이 더 안정적으로 원하는 출력 생성."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#대-원칙",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#대-원칙",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.1 4.1 4대 원칙",
    "text": "4.1 4.1 4대 원칙\n\n범용성: 다양한 상황에서도 동작\n목적 지향성: 특정 사용자 목적 반영\n일관성: 반복 실행해도 동일 품질\n경제성: API 비용 절감"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#scaffolding-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#scaffolding-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.2 4.2 Scaffolding Prompting",
    "text": "4.2 4.2 Scaffolding Prompting\n\n인간의 학습 이론(ZPD)을 적용\nUnderstand → Ideation → Analysis → Apply → Evaluate → Generalize\n단계적 사고구조 유도"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#핵심-5-tips",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#핵심-5-tips",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.3 4.3 핵심 5 Tips",
    "text": "4.3 4.3 핵심 5 Tips\n\n4.3.1 Tip1. 최신 모델 사용\n\n\n4.3.2 Tip2. 명확한 동사로 지시\n예: 분석해, 정리해, 요약해, 작성해 등\n\n\n4.3.3 Tip 3. 프롬프트를 구조화하자\n프롬프트를 구조화하면 LLM이 입력을 더 명확하게 해석할 수 있고,\n작업 목적·규칙·입력 데이터·출력 형식을 혼동 없이 처리할 수 있다.\n구조화를 위한 핵심 기법은 Markdown, 코드 프롬프트, XML 태그이다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#markdown-구조화-headers-lists-emphasis",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)",
    "text": "4.4 3.1 Markdown 구조화 (Headers, Lists, Emphasis)\nMarkdown은 LLM이 가장 잘 해석하는 구조적 문법 중 하나이다.\n섹션을 명확히 나누고, 각 부분을 시각적으로 구분해줌으로써\n모델의 오류를 줄이고 반복 작업 시 유지보수성이 높아진다.\n\n4.4.1 1) 헤더(Headers) 활용\n헤더는 프롬프트의 구성을 크게 나누는 데 사용한다.\n# 역할(Role)\n너는 스포츠 기사 분석 엔진이다.\n\n## 작업(Task)\n아래 텍스트에서 장소(도시, 국가, 축구 클럽)를 모두 추출해라.\n\n## 출력 형식(Format)\n- \"장소: A, B, C\" 형태의 한 줄 출력\n- 설명 금지\n\n## 텍스트(Text)\n{{TEXT}}\n\n\n4.4.2 2) 목록(Lists) 활용\n절차, 규칙, 조건을 번호 목록으로 정리하면 LLM이 하나씩 적용하기 쉽다.\n다음 규칙을 따라 작업을 수행해라.\n1. 사람 이름은 제외한다.\n2. 축구 클럽은 장소로 포함한다.\n3. 결과는 쉼표로 구분한다.\n4. 설명 문장은 쓰지 않는다.\n\n\n4.4.3 3) 강조(Emphasis) 사용\n중요 조건을 굵게 또는 기울임으로 표시해 모델의 우선순위를 높인다.\n- 반드시 **한국어**로 작성하라.\n- 출력은 **한 줄**로만 작성한다.\n- *설명 문장은 포함하지 않는다.*"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#코드-프롬프트code-prompting",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.5 3.2 코드 프롬프트(Code Prompting)",
    "text": "4.5 3.2 코드 프롬프트(Code Prompting)\n자연어 대신 코드 형식으로 의도를 명세하면 애매함이 줄어들고 LLM이 구조적으로 이해해 할루시네이션이 감소한다.\n# 역할 정의\nrole = \"정보 추출 엔진\"\n\n# 작업 정의\ntask = \"텍스트에서 '장소명'을 추출해 정렬된 리스트로 반환\"\n\n# 출력 형식 정의\noutput = {\n    \"places\": [\"string\"]\n}\n코드 방식의 장점:\n\n논리 구조가 명확하게 표현됨\n조건과 출력 형식이 혼동되지 않음\n정형화된 포맷을 자주 재사용 가능"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#xml-태그-기반-구조화-claude-최적화",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)",
    "text": "4.6 3.3 XML 태그 기반 구조화 (Claude 최적화)\nXML 태그는 텍스트 내 특정 영역을 명확히 구분해 Claude뿐 아니라 대부분의 LLM에서 구조적 파싱을 돕는 강력한 방식이다.\n\n4.6.1 1) 태그로 영역 지정\n&lt;email&gt;\nShow up at 6AM because I say so.\n&lt;/email&gt;\n\nMake this email more polite.\nLLM은 &lt;email&gt;...&lt;/email&gt; 내부 텍스트만 변환하면 된다는 것을 명확히 인식한다.\n\n\n4.6.2 2) 데이터 템플릿 예시\n&lt;animal&gt;{{ANIMAL}}&lt;/animal&gt;\n입력만 바꿔 여러 데이터를 동일한 템플릿에 적용할 수 있다.\n예:\n&lt;animal&gt;Cow&lt;/animal&gt;\n&lt;animal&gt;Dog&lt;/animal&gt;\n&lt;animal&gt;Seal&lt;/animal&gt;\n장점:\n\n구역별 의미가 명확\n반복 작업에서 수정이 쉽고 안정적\n모델이 태그 단위로 파싱하기 때문에 오류 감소"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#구조화-기법이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.7 3.4 구조화 기법이 필요한 이유",
    "text": "4.7 3.4 구조화 기법이 필요한 이유\n\n명령어, 입력 데이터, 출력 형식을 명확히 구분해 모델의 해석 오류를 줄인다.\n규칙을 시각적으로 구분하여 작업 수행 품질의 일관성과 재현성을 높인다.\n재사용 가능한 템플릿이 되어 프롬프트 제작 비용과 시간 절감에 기여한다."
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#구조화-적용-사례-장소명-추출",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "4.8 3.5 구조화 적용 사례 (장소명 추출)",
    "text": "4.8 3.5 구조화 적용 사례 (장소명 추출)\n# 역할(Role)\n너는 텍스트에서 장소명을 추출하는 엔진이다.\n\n## 작업(Task)\n텍스트 내 도시, 국가, 축구 클럽 이름을 모두 \"장소\"로 간주하고 추출해라.\n\n## 출력 형식(Format)\n- 한 줄로만 출력한다.\n- 형식: `장소: A, B, C`\n- 설명 문장 금지.\n\n## 텍스트(Text)\n음바페는 26일 쿠프 드 프랑스 프랑스컵 올랭피크 리옹과의\n결승전에서 풀타임을 뛰며 2-1로 팀 승리를 도왔다.\n3년 만에 대회 정상에 오른 PSG는 역대 최다 15회 우승으로\n2위 마르세유(10회)를 멀찍이 따돌렸다.\n음바페는 이날 PSG에서의 커리어를 마무리했다.\n\n4.8.1 Tip4. 단문 중심\n\n한국어는 짧고 명확하게 작성\n톤·형식·분량을 구체적으로 지시\n\n\n\n4.8.2 Tip5. 하지 말 것(X) → 할 것(O)\n\n부정 지시보다 긍정적 행동 지시가 안정적"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#llm-한계",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#llm-한계",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.1 5.1 LLM 한계",
    "text": "5.1 5.1 LLM 한계\n\n할루시네이션\n편향성\n근거 없는 출처 생성\n수학 및 추론 한계\nPrompt Injection(프롬프트 해킹)"
  },
  {
    "objectID": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "href": "docs/blog/posts/Prompt_Engineering/01-Prompt-Structure copy/01-Prompt-Structure.html#프롬프트-엔지니어링이-필요한-이유",
    "title": "Part 1 — 프롬프트 구조와 기능 탐구",
    "section": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유",
    "text": "5.2 5.2 프롬프트 엔지니어링이 필요한 이유\n\n정확성 향상\n오류 및 편향 감소\n모델 행동 제어\n사용자 경험 개선\n비용 절감"
  }
]